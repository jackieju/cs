//****************************************************************
//   CPLUS2\PARSER_C.FRM
//   Coco/R C++ Support Frames.
//   Author: Frankie Arzu <farzu@uvg.edu.gt>
//
//   Jun 12, 1996  Version 1.06
//      Many fixes and suggestions thanks to
//      Pat Terry <p.terry@.ru.ac.za>
//   Oct 11, 1997  Version 1.07
//      Eliminated redundant ";" in some places
//****************************************************************

/*************** NOTICE ****************
	This file is generated by cocoR       
***************************************/

#include "clib.h"
#include "log.h"
#include "cc.hpp"

# line 10 "cs.atg"
/////////////////////////////////
// add by jackie juju
#include "clib.h"
#include <string.h>
#include <vector>
#include <string>
#include "datatype.h"
#include "LoopTree.h"
#include "opcode.h"
#include "CSS_LOCKEX.h"
#include "ScriptFuncTable.h"
#include "log.h"
#include "PubFuncTable.h"
#include "ClassDes.h"
#include "compiler.h"
#include "utility.h"

#define CAST Cast(op1, type1, dt1, op2, type2, dt2);


// add by jackie juju
/////////////////////////////////



#include "cp.hpp"
#include "cs.hpp"

unsigned short int cParser::SymSet[][MAXSYM] = {
  /*EOF_Sym */
  {0x1,0x0,0x0,0x0,0x0,0x0},
  
  {0x0}
};
BOOL cParser::init(CClassDesTable *table, CPubFuncTable* pft, CConfigure* c){
	m_classTable = table;
	m_PubFuncTable = pft;
	m_conf = c;
	// show options
	showOptions();
	return TRUE;
}

void cParser::destroy(){

}
void cParser::Get()
{ do {
    Sym = Scanner->Get();//aa
    Scanner->NextSym.SetSym(Sym);
    if (Sym <= MAXT) Error->ErrorDist ++;
    else {
      if (Sym == PreProcessorSym) { /*84*/
      # line 63 "cs.atg"
	
      	    // process #include                                 
      	char str[256];
      	Scanner->GetName(&Scanner->NextSym, str, 255);
      	// get directive
      	char* p = strchr(str, ' ');
      	char* directive = NULL;
      	char* content = NULL;
      	if ( p != NULL ){
      	    *p=0; 
      	    directive = str + sizeof(char);
      	    // proce include 
      	    if (strcmp(str, "include") == 0){
      	            // get content
      	            p += sizeof(char);
      	            while ( (*p == ' ' || *p == '\t' ) && *p != '\0' ){
      	                    p += sizeof(char);              
      	            }
      	            if ( *p != '\0' )
      	                    content = p;
      	    }
      	
      	}
      	    
      	    ;
      } else
      /* Empty Stmt */ ;
      Scanner->NextSym = Scanner->CurrSym;
    }
  } while (Sym > MAXT);
}

void cParser::ExpectWeak(int n, int follow)
{ if (Sym == n) Get();
  else {
    GENERR(n);
    while (!(In(SymSet[follow], Sym) || In(SymSet[0], Sym))) Get();
  }
}

int cParser::WeakSeparator(int n, int syFol, int repFol)
{ unsigned short int s[MAXSYM];
  int i;

  if (Sym == n) { Get(); return 1; }
  if (In(SymSet[repFol], Sym)) return 0;

  for (i = 0; i < MAXSYM; i++)
    s[i] = SymSet[0][i] | SymSet[syFol][i] | SymSet[repFol][i];
  GENERR(n);
  while (!In(s, Sym)) Get();
  return In(SymSet[syFol], Sym);
}

# line 96 "cs.atg"
void cParser::C()
{
# line 96 "cs.atg"
	
	
	CClassDes *pNewCD = new CClassDes(this);
	if (m_pCurClassDes != NULL){
	pNewCD->setParent(m_pCurClassDes);
	}
	m_pCurClassDes = pNewCD;
	//std::string className = JUJU::getFileName(curFileName);
	//m_pCurClassDes->SetName((char*)className.c_str());   
	m_pCurClassDes->setName("_global_");
	// add class def first because it maybe referenced by its own code
	m_classTable->addClass(m_pCurClassDes);
	
	// set main function and add to class _global_
	this->m_pMainFunction = m_pCurClassDes;
	m_pMainFunction->m_SymbolTable.m_pParser = this;
	this->m_LoopTree->m_pFunc = m_pMainFunction;
	//      m_pMainFunction->setName("create");
	//      m_pCurClassDes->AddMethod(m_pMainFunction);
	//      m_pMainFunction->setParent(m_pCurClassDes);
	// add "this" as first parameter to function 
	PTYPEDES type = new TYPEDES;
	type->refLevel = 0;
	type->type = dtGeneral;
	if (!AllocVar(type, "this"))
	GENERR(113);
	else
	m_pMainFunction->m_iParamTotalSize += this->UnitSize(*type);
	delete type;
	
	printf("m_pMainFunction1=%x", m_pMainFunction);
# line 128 "cs.atg"
	while (Sym == useSym ||
	       Sym == loadSym) {
# line 128 "cs.atg"
		if (Sym == useSym) {
# line 128 "cs.atg"
			Import();
		} else if (Sym == loadSym) {
# line 128 "cs.atg"
			LoadLib();
		} else GenError(85);
	}
# line 128 "cs.atg"
	if (Sym >= inheritSym && Sym <= LessSym) {
# line 128 "cs.atg"
		Inheritance();
	}
# line 130 "cs.atg"
	while (Sym >= identifierSym && Sym <= numberSym ||
	       Sym >= stringD1Sym && Sym <= charD1Sym ||
	       Sym == SemicolonSym ||
	       Sym >= classSym && Sym <= LbraceSym ||
	       Sym >= staticSym && Sym <= stringSym ||
	       Sym == LparenSym ||
	       Sym >= StarSym && Sym <= caseSym ||
	       Sym >= defaultSym && Sym <= ifSym ||
	       Sym >= returnSym && Sym <= switchSym ||
	       Sym == AndSym ||
	       Sym >= PlusSym && Sym <= MinusSym ||
	       Sym >= PlusPlusSym && Sym <= MinusMinusSym ||
	       Sym >= newSym && Sym <= DollarSym ||
	       Sym >= BangSym && Sym <= TildeSym) {
# line 130 "cs.atg"
		Definition();
	}
# line 130 "cs.atg"
	Expect(EOF_Sym);
# line 130 "cs.atg"
	
	/*
	if (Error->Errors){ // if compile failed, remove this class
	m_classTable->removeClass((char*)className.c_str());
	}*/
	//      std::string name = m_pCurClassDes->GetFullName();
	//    name += ".class";
	//FILE* file = fopen(name.c_str(), "w");
	//std::string *s = m_pCurClassDes->output();
	//fprintf(file, "%s", s->c_str());
	//SAFEDELETE(s);
	//fclose(file);
	
	// add return statement
	ADDCOMMAND0(__ret);
	
	 char path[_MAX_PATH];
	      if (strlen(m_szByteCodeFilePath) == 0 )
	              sprintf(path, "%s.%s", this->m_pCurClassDes->GetFullName(),"_self_");
	      else
	              sprintf(path, "%s%s%s.%s", m_szByteCodeFilePath, PATH_SEPARATOR_S, this->m_pCurClassDes->GetFullName(),"_self_");
	m_pMainFunction->Output(path);
}

# line 154 "cs.atg"
void cParser::Import()
{
# line 154 "cs.atg"
	Expect(useSym);
# line 154 "cs.atg"
	char szName[_MAX_PATH]= "";
# line 154 "cs.atg"
	ClassFullName(szName);
# line 155 "cs.atg"
	
	    // load class by name, if not found, look for the source and compile it
	    CClassDes* cd = this->m_classTable->getClass(szName);
	    if (cd == NULL){
	            strcat(szName, SCRIPT_EXT);
	                                            CCompiler cc;
	                             std::string s = JUJU::getFilePath(c->getCurSrcFile())+szName;
	                                    printf("current file: %s\n", c->getCurSrcFile());
	                                    printf("current file path: %s\n", JUJU::getFilePath(c->getCurSrcFile()).c_str());
	                                    printf("use %s\n", szName);
	                                                            if (m_conf)     
	                                                                    cc.setConf(*m_conf);
	                                                            // add path of current class file to class path
	                                                            cc.getClassPath().insert(cc.getClassPath().begin(), JUJU::getFilePath(c->getCurSrcFile()));
	                                cc.Compile(szName);
	    };
# line 171 "cs.atg"
	Expect(SemicolonSym);
}

# line 173 "cs.atg"
void cParser::LoadLib()
{
# line 173 "cs.atg"
	Expect(loadSym);
# line 173 "cs.atg"
	Expect(identifierSym);
# line 174 "cs.atg"
	
	        // load external library 
	        std::string lib = GetCurrSym();
	    #ifdef          WIN32
	        std::string libfile = lib+".dll";
	    #else
	            std::string libfile = "lib"+lib+".so";
	    #endif
	        std::string libintfile = lib+".int";
	    
	    int r=-1;
	#ifdef WIN32
	            r = m_PubFuncTable->LoadLib((char*)libfile.c_str(), (char*)libintfile.c_str());
	#else
	        char* c1 = (char*)(libfile).c_str();
	        char* c2 = (char*)(libintfile).c_str();
	            r = m_PubFuncTable->LoadLib(c1, c2);
	#endif
	            if (r){
	                    GENERR(128);
	            }
	/* for the further if VM run in another process than compiler run
	    int address = m_pMainFunction->AddStaticData(lib.size()+1, (BYTE*)lib.c_str());
	    ADDCOMMAND1(__loadlib, DS, address);
	*/              ;
# line 200 "cs.atg"
	Expect(SemicolonSym);
}

# line 216 "cs.atg"
void cParser::Inheritance()
{
# line 216 "cs.atg"
	if (Sym == inheritSym) {
# line 216 "cs.atg"
		Get();
	} else if (Sym == LessSym) {
# line 216 "cs.atg"
		Get();
	} else GenError(86);
# line 216 "cs.atg"
	Expect(identifierSym);
# line 217 "cs.atg"
	
	
	// TODO get full name in current imported classes, should not need to provide full name here
	    char* szName = GetCurrSym();
	    CClassDes* cd = this->m_classTable->getClass(szName);
	    if (cd == NULL){
	            std::string s = JUJU::getFilePath(c->getCurSrcFile())+szName;
	            strcpy(szName, s.c_str());
	            cd = this->m_classTable->getClass(szName);
	            if (cd == NULL){
	                            strcat(szName, SCRIPT_EXT);
	                            CCompiler cc;                         
	                cc.Compile(szName);
	        }
	    }
	//      this->m_pCurClassDes->setParent(szName);
	    this->m_pCurClassDes->setParent(cd);
# line 234 "cs.atg"
	Expect(SemicolonSym);
}

# line 206 "cs.atg"
void cParser::Definition()
{
# line 206 "cs.atg"
	debug("===>Definition");
# line 207 "cs.atg"
	if (Sym == classSym) {
# line 207 "cs.atg"
		ClassDef();
	} else if (Sym >= EOF_Sym && Sym <= numberSym ||
	           Sym >= stringD1Sym && Sym <= charD1Sym ||
	           Sym == SemicolonSym ||
	           Sym >= LbraceSym && Sym <= stringSym ||
	           Sym == LparenSym ||
	           Sym >= StarSym && Sym <= caseSym ||
	           Sym >= defaultSym && Sym <= ifSym ||
	           Sym >= returnSym && Sym <= switchSym ||
	           Sym == AndSym ||
	           Sym >= PlusSym && Sym <= MinusSym ||
	           Sym >= PlusPlusSym && Sym <= MinusMinusSym ||
	           Sym >= newSym && Sym <= DollarSym ||
	           Sym >= BangSym && Sym <= TildeSym) {
# line 207 "cs.atg"
		Statements();
	} else GenError(87);
}

# line 2201 "cs.atg"
void cParser::ClassFullName(char* szName)
{
# line 2202 "cs.atg"
	Expect(identifierSym);
# line 2202 "cs.atg"
	strcpy(szName, GetCurrSym());
# line 2203 "cs.atg"
	while (Sym == ColonColonSym) {
# line 2203 "cs.atg"
		Get();
# line 2203 "cs.atg"
		strcat(szName, PATH_SEPARATOR_S);
# line 2204 "cs.atg"
		Expect(identifierSym);
# line 2204 "cs.atg"
		strcat(szName, GetCurrSym());
	}
}

# line 237 "cs.atg"
void cParser::ClassDef()
{
# line 237 "cs.atg"
	Expect(classSym);
# line 237 "cs.atg"
	Expect(identifierSym);
# line 238 "cs.atg"
	
	      // get name
	      char *szName = new char[MAX_IDENTIFIER_LENGTH];
	      memset(szName, 0, MAX_IDENTIFIER_LENGTH);
	      Scanner->GetName(&Scanner->CurrSym, szName, MAX_IDENTIFIER_LENGTH-1);//得到名称
	              printf("m_pMainFunction2=%x", m_pMainFunction);
	      CClassDes * pNewCD = new CClassDes(this);
	      pNewCD->setParent(m_pMainFunction);
	      m_pMainFunction =  m_pCurClassDes = pNewCD;
	      // std::string className = JUJU::getFileName(curFileName);
	       m_pCurClassDes->setName(szName);       
	      
	      // add class def first because it maybe referenced by its own code
	       m_classTable->addClass(m_pCurClassDes);
	      
	
# line 255 "cs.atg"
	while (Sym >= inheritSym && Sym <= LessSym) {
# line 255 "cs.atg"
		Inheritance();
	}
# line 256 "cs.atg"
	ClassBody();
# line 256 "cs.atg"
	Expect(SemicolonSym);
}

# line 642 "cs.atg"
void cParser::Statements()
{
# line 642 "cs.atg"
	while (Sym >= identifierSym && Sym <= numberSym ||
	       Sym >= stringD1Sym && Sym <= charD1Sym ||
	       Sym == SemicolonSym ||
	       Sym == LbraceSym ||
	       Sym >= staticSym && Sym <= stringSym ||
	       Sym == LparenSym ||
	       Sym >= StarSym && Sym <= caseSym ||
	       Sym >= defaultSym && Sym <= ifSym ||
	       Sym >= returnSym && Sym <= switchSym ||
	       Sym == AndSym ||
	       Sym >= PlusSym && Sym <= MinusSym ||
	       Sym >= PlusPlusSym && Sym <= MinusMinusSym ||
	       Sym >= newSym && Sym <= DollarSym ||
	       Sym >= BangSym && Sym <= TildeSym) {
# line 642 "cs.atg"
		if (Sym >= staticSym && Sym <= stringSym) {
# line 642 "cs.atg"
			LocalDeclaration();
		} else if (Sym >= identifierSym && Sym <= numberSym ||
		           Sym >= stringD1Sym && Sym <= charD1Sym ||
		           Sym == SemicolonSym ||
		           Sym == LbraceSym ||
		           Sym == LparenSym ||
		           Sym >= StarSym && Sym <= caseSym ||
		           Sym >= defaultSym && Sym <= ifSym ||
		           Sym >= returnSym && Sym <= switchSym ||
		           Sym == AndSym ||
		           Sym >= PlusSym && Sym <= MinusSym ||
		           Sym >= PlusPlusSym && Sym <= MinusMinusSym ||
		           Sym >= newSym && Sym <= DollarSym ||
		           Sym >= BangSym && Sym <= TildeSym) {
# line 642 "cs.atg"
			Statement();
		} else GenError(88);
	}
# line 642 "cs.atg"
	        printf("1m_pMainFunction=%x", m_pMainFunction);
}

# line 257 "cs.atg"
void cParser::ClassBody()
{
# line 258 "cs.atg"
	
	debug("===>classbody");
	// 利用CFunction来存放类成员
	/*      CFunction* pSaved = this->m_pMainFunction;      // save current function
	CFunction function;
	function.m_SymbolTable.m_pParser = this;
	this->m_pMainFunction = &function;*/
	
	
	//      m_pMainFunction = m_pCurClassDes;
	m_pMainFunction->m_SymbolTable.m_pParser = this;
	this->m_LoopTree->m_pFunc = m_pMainFunction;
	// add "this" as first parameter to function 
	PTYPEDES type = new TYPEDES;
	type->refLevel = 0;
	type->type = dtGeneral;
	if (!AllocVar(type, "this"))
	      GENERR(113);
	else
	      m_pMainFunction->m_iParamTotalSize += this->UnitSize(*type);
	delete type;
	      
	
# line 282 "cs.atg"
	Expect(LbraceSym);
# line 282 "cs.atg"
	while (Sym >= identifierSym && Sym <= numberSym ||
	       Sym >= stringD1Sym && Sym <= charD1Sym ||
	       Sym == SemicolonSym ||
	       Sym >= classSym && Sym <= LbraceSym ||
	       Sym >= staticSym && Sym <= stringSym ||
	       Sym == LparenSym ||
	       Sym >= StarSym && Sym <= caseSym ||
	       Sym >= defaultSym && Sym <= ifSym ||
	       Sym >= returnSym && Sym <= switchSym ||
	       Sym == AndSym ||
	       Sym >= PlusSym && Sym <= MinusSym ||
	       Sym >= PlusPlusSym && Sym <= MinusMinusSym ||
	       Sym >= newSym && Sym <= DollarSym ||
	       Sym >= BangSym && Sym <= TildeSym) {
# line 282 "cs.atg"
		Definition();
	}
# line 282 "cs.atg"
	Expect(RbraceSym);
# line 284 "cs.atg"
	
	
	m_pMainFunction = m_pCurClassDes;
	// call construction function "create"
	FUNCCALL fn;
	CFunction* pScript = m_pCurClassDes->getMethod("create");       
	fn.name = "::create";
	
	fn.pVF = pScript;
	fn.nType = 0;
	ADDCOMMAND1(__callv, CC, (long)pScript);
	                      
	// add "this" as first parameter
	printf("add this as parameter for class method\n");
	ADDCOMMAND1(__paramv, 0xc100, 0);
	ADDCOMMAND0(__endcallv);
	m_pCurClassDes->getFuncTable()->ReleaseFunc();
	
	ADDCOMMAND0(__ret);
	m_pMainFunction = m_pMainFunction->getParent();
	
	      printf("m_pMainFunction3=%x", m_pMainFunction);
	/*
	//添加class
	if (!Error->Errors)
	{
	      CObjDes* pClass = new CObjDes(this);
	      pClass->SetName(szName);
	      if (!pClass)
	      {
	              REPORT_MEM_ERROR("Allcotion memory failed")
	      }
	      else
	      {
	              for (int i = 0; i < function.m_SymbolTable.m_nSymbolCount; i++)
	              {
	                      if (!pClass->AddMember(function.m_SymbolTable.tableEntry[i].szName, 
	                              function.m_SymbolTable.tableEntry[i].type))
	                      {
	                              if (pClass)
	                              {
	                                      delete pClass;
	                                      pClass = NULL;
	                              }
	                              GENERR(118);                                    
	                              break;
	                      }
	              }
	      }
	      if (!this->AddObj(*pClass))
	      {
	              GENERR(119);                            
	              if (pClass)
	              {
	                      delete pClass;
	                      pClass = NULL;
	              }
	      }
	}
	              */
	;
}

# line 348 "cs.atg"
void cParser::StorageClass()
{
# line 350 "cs.atg"
	if (Sym == staticSym) {
# line 349 "cs.atg"
		Get();
	} else if (Sym == mySym) {
# line 350 "cs.atg"
		Get();
	} else if (Sym == functionSym) {
# line 351 "cs.atg"
		Get();
	} else GenError(89);
}

# line 354 "cs.atg"
void cParser::Type(PTYPEDES type)
{
# line 377 "cs.atg"
	switch (Sym) {
		case varSym: 
		case mixedSym:  
# line 360 "cs.atg"
			if (Sym == varSym) {
# line 360 "cs.atg"
				Get();
			} else if (Sym == mixedSym) {
# line 360 "cs.atg"
				Get();
			} else GenError(90);
# line 361 "cs.atg"
			
			              /*      #ifdef __SUPPORT_OBJ
			                      char szName[MAX_IDENTIFIER_LENGTH];
			                      memset(szName, 0, MAX_IDENTIFIER_LENGTH);
			                      Scanner->GetName(&Scanner->CurrSym, szName, MAX_IDENTIFIER_LENGTH-1);//得到名称                     
			                      type->type = dtGeneral;
			                      type->objID = GetObjIDByName(szName); 
			                      if (type->objID == 0)
			                              GENERR(120);
			                      #else
			                      // TODO
			                              GENERR(120);
			                      #endif
			*/
			      type->type = dtGeneral; type->refLevel = 0;
			break;
		case shortSym:  
# line 378 "cs.atg"
			Get();
# line 378 "cs.atg"
			if (Sym == intSym) {
# line 378 "cs.atg"
				Get();
			}
# line 379 "cs.atg"
			                         type->type = dtShort; type->refLevel = 0;      
			break;
		case longSym:  
# line 380 "cs.atg"
			Get();
# line 380 "cs.atg"
			if (Sym == intSym ||
			    Sym == floatSym) {
# line 380 "cs.atg"
				if (Sym == intSym) {
# line 380 "cs.atg"
					Get();
				} else if (Sym == floatSym) {
# line 380 "cs.atg"
					Get();
				} else GenError(91);
			}
# line 381 "cs.atg"
			                         type->type = dtLong; type->refLevel = 0;
			break;
		case unsignedSym:  
# line 382 "cs.atg"
			Get();
# line 382 "cs.atg"
			if (Sym >= intSym && Sym <= longSym ||
			    Sym == charSym) {
# line 382 "cs.atg"
				if (Sym == charSym) {
# line 382 "cs.atg"
					Get();
				} else if (Sym == intSym) {
# line 382 "cs.atg"
					Get();
				} else if (Sym == longSym) {
# line 382 "cs.atg"
					Get();
				} else GenError(92);
			}
			break;
		case charSym:  
# line 383 "cs.atg"
			Get();
# line 384 "cs.atg"
			                        type->type = dtChar;                    type->refLevel = 0;
			break;
		case intSym:  
# line 385 "cs.atg"
			Get();
# line 386 "cs.atg"
			                         type->type = dtInt; type->refLevel = 0;
			break;
		case floatSym:  
# line 387 "cs.atg"
			Get();
# line 388 "cs.atg"
			                        type->type = dtFloat;                   type->refLevel = 0;
			break;
		case doubleSym:  
# line 390 "cs.atg"
			Get();
			break;
		case voidSym:  
# line 390 "cs.atg"
			Get();
			break;
		case stringSym:  
# line 390 "cs.atg"
			Get();
# line 391 "cs.atg"
			type->type =  dtStr;            type->refLevel = 0;
			break;
		default :GenError(93); break;
	}
}

# line 394 "cs.atg"
void cParser::VarList(PTYPEDES type, char* szFirstName)
{
# line 395 "cs.atg"
	ArraySize();
# line 396 "cs.atg"
	
	      doVarDecl(type, szFirstName);
	      char szName[MAX_IDENTIFIER_LENGTH];
# line 399 "cs.atg"
	if (Sym == EqualSym) {
# line 399 "cs.atg"
		Get();
# line 399 "cs.atg"
		Expression();
# line 399 "cs.atg"
		debug("assignment");doAssign();
	}
# line 400 "cs.atg"
	while (Sym == CommaSym) {
# line 400 "cs.atg"
		Get();
# line 400 "cs.atg"
		Expect(identifierSym);
# line 401 "cs.atg"
		
		              memset(szName, 0, MAX_IDENTIFIER_LENGTH-1);
		              Scanner->GetName(&Scanner->CurrSym, szName, MAX_IDENTIFIER_LENGTH);
		              
		
# line 408 "cs.atg"
		ArraySize();
# line 409 "cs.atg"
		
		               doVarDecl(type, szName);
# line 412 "cs.atg"
		if (Sym == EqualSym) {
# line 412 "cs.atg"
			Get();
# line 412 "cs.atg"
			Expression();
# line 412 "cs.atg"
			        doAssign();
		}
	}
}

# line 415 "cs.atg"
void cParser::ArraySize()
{
# line 415 "cs.atg"
	while (Sym == LbrackSym) {
# line 415 "cs.atg"
		Get();
# line 415 "cs.atg"
		if (Sym >= identifierSym && Sym <= numberSym ||
		    Sym >= stringD1Sym && Sym <= charD1Sym ||
		    Sym == LbraceSym ||
		    Sym == LparenSym ||
		    Sym == StarSym ||
		    Sym == AndSym ||
		    Sym >= PlusSym && Sym <= MinusSym ||
		    Sym >= PlusPlusSym && Sym <= MinusMinusSym ||
		    Sym >= newSym && Sym <= DollarSym ||
		    Sym >= BangSym && Sym <= TildeSym) {
# line 415 "cs.atg"
			ConstExpression();
		}
# line 415 "cs.atg"
		Expect(RbrackSym);
	}
}

# line 915 "cs.atg"
void cParser::Expression()
{
# line 915 "cs.atg"
	debug("===>Expression");
# line 915 "cs.atg"
	Conditional();
# line 915 "cs.atg"
	while (Sym == EqualSym ||
	       Sym >= StarEqualSym && Sym <= GreaterGreaterEqualSym) {
# line 915 "cs.atg"
		AssignmentOperator();
# line 915 "cs.atg"
		Expression();
# line 916 "cs.atg"
		
		printf("===>AssignmentOperator\n");
		    if (!doAssign()) 
		            continue;
		
	}
}

# line 913 "cs.atg"
void cParser::ConstExpression()
{
# line 913 "cs.atg"
	Expression();
}

# line 419 "cs.atg"
void cParser::FunctionDefinition()
{
# line 420 "cs.atg"
	
	    this->m_pMainFunction = new CFunction();
	
	    //for test
	    long t = sizeof(CFunction);
	    m_pMainFunction->m_SymbolTable.m_pParser = this;
	    this->m_LoopTree->m_pFunc = m_pMainFunction;
	    
	    char szName[MAX_IDENTIFIER_LENGTH];
	    memset(szName, 0, MAX_IDENTIFIER_LENGTH);
	    Scanner->GetName(&Scanner->CurrSym, szName, MAX_IDENTIFIER_LENGTH-1);//得到名称
	
	    if (strlen(szName) > 20)
	            GENERR(105);
	    else
	            strcpy(m_pMainFunction->m_szName, szName);
	            
	    // add "this" as first parameter to function if it belong to a class
	    if (m_pCurClassDes){
	            if (m_pCurClassDes != m_pMainFunction){
	            //      m_pCurClassDes->AddMethod(m_pMainFunction);
	                    m_pMainFunction->setParent(m_pCurClassDes);
	            }
	            PTYPEDES type = new TYPEDES;
	            type->refLevel = 0;
	            type->type = dtGeneral;
	            if (!AllocVar(type, "this"))
	                    GENERR(113);
	            else
	                    m_pMainFunction->m_iParamTotalSize += this->UnitSize(*type);
	            delete type;
	    }
	
	    printf("--->FunctionDefinition:: m_pMainFunction=%x, name=%s, expStockPt=%x, m_iParamTotalSize=%d\n", m_pMainFunction, m_pMainFunction->name(), m_pMainFunction->m_pExpDigitPt, m_pMainFunction->m_iParamTotalSize);
	
	            
# line 457 "cs.atg"
	FunctionHeader();
# line 457 "cs.atg"
	FunctionBody();
# line 458 "cs.atg"
	
	    if (!this->Error->Errors)
	    {
	               char path[_MAX_PATH];
	                            if (strlen(m_szByteCodeFilePath) == 0 )
	                                    sprintf(path, "%s.%s", this->m_pCurClassDes->GetFullName(),szName);
	                            else
	                                    sprintf(path, "%s%s%s.%s", m_szByteCodeFilePath, PATH_SEPARATOR_S, this->m_pCurClassDes->GetFullName(),szName);
	                m_pMainFunction->Output(path);
	            
	    }else{
	    printf("--->m_pMainFunction22=%x, name=%s\n", m_pMainFunction, m_pMainFunction->name());
	            //SAFEDELETE( m_pMainFunction);         
	            if (m_pMainFunction!=NULL){
	                    printf("--->m_pMainFunction221=%x, name=%s\n", m_pMainFunction, m_pMainFunction->name());
	//                      delete m_pMainFunction;
	
	                    m_pMainFunction = m_pMainFunction->getParent();
	            }
	     }
	     m_pMainFunction =m_pMainFunction->getParent();
	    //      printf("--->m_pMainFunction23=%x\n", m_pMainFunction);
	    
}

# line 483 "cs.atg"
void cParser::FunctionHeader()
{
# line 484 "cs.atg"
	
	    
	
	
# line 491 "cs.atg"
	Expect(LparenSym);
# line 491 "cs.atg"
	if (Sym == identifierSym ||
	    Sym >= varSym && Sym <= stringSym) {
# line 491 "cs.atg"
		FormalParamList();
	}
# line 491 "cs.atg"
	Expect(RparenSym);
# line 492 "cs.atg"
	        
	m_pMainFunction->ClearExpStack();
	//printf("add function%s line=%d\n",  m_pMainFunction->name(), Scanner->CurrSym.Line);
	this->m_pMainFunction->m_iParamNum = this->m_pMainFunction->m_SymbolTable.m_nSymbolCount; 
	           if (m_pCurClassDes != m_pMainFunction)
	                   m_pCurClassDes->AddMethod(m_pMainFunction);
	/*if          (!m_pCurClassDes->getFuncTable()->AddFunction(this->m_pMainFunction))
	           {
	                   GENERR(114);
	           }               
	*/;
}

# line 504 "cs.atg"
void cParser::FunctionBody()
{
# line 504 "cs.atg"
	CompoundStatement();
# line 504 "cs.atg"
	        ADDCOMMAND0(__ret);
}

# line 505 "cs.atg"
void cParser::FormalParamList()
{
# line 505 "cs.atg"
	FormalParameter();
# line 505 "cs.atg"
	while (Sym == CommaSym) {
# line 505 "cs.atg"
		Get();
# line 505 "cs.atg"
		FormalParameter();
	}
}

# line 640 "cs.atg"
void cParser::CompoundStatement()
{
# line 640 "cs.atg"
	Expect(LbraceSym);
# line 640 "cs.atg"
	Statements();
# line 640 "cs.atg"
	Expect(RbraceSym);
}

# line 506 "cs.atg"
void cParser::FormalParameter()
{
# line 506 "cs.atg"
	PTYPEDES type = new TYPEDES; ;          type->type = dtGeneral; type->refLevel = 0;
# line 506 "cs.atg"
	while (Sym >= varSym && Sym <= stringSym) {
# line 507 "cs.atg"
		Type(type);
# line 507 "cs.atg"
		while (Sym == StarSym) {
# line 507 "cs.atg"
			//test;
# line 507 "cs.atg"
			Get();
# line 507 "cs.atg"
			type->refLevel++;
		}
	}
# line 508 "cs.atg"
	Expect(identifierSym);
# line 509 "cs.atg"
	
	   char szName[MAX_IDENTIFIER_LENGTH];
	   memset(szName, 0, MAX_IDENTIFIER_LENGTH-1);
	   Scanner->GetName(&Scanner->CurrSym, szName, MAX_IDENTIFIER_LENGTH);
# line 514 "cs.atg"
	while (Sym == LbrackSym) {
# line 514 "cs.atg"
		ArraySize();
# line 515 "cs.atg"
		
		     if (type->type == dtGeneral){
		             fprintf(stderr, "Cannot specify array for a var type variable");
		     }else{
		     long op;
		     long type1;
		     TYPEDES DT1;
		     
		     if (!m_pMainFunction->PopDigit(&op, &type1, &DT1) || type1 <FIRST_ADDRESS_MODE || type1 >LAST_ADDRESS_MODE)
		     {
		
		             if (type->objID > 0 && type->type == dtGeneral && type->refLevel == 0)//如果是结构， 生成他的指针
		             {
		                     type->refLevel++;
		             }
		             if (!AllocVar(type, szName))
		                     GENERR(113);
		             else
		                     m_pMainFunction->m_iParamTotalSize += this->UnitSize(*type);
		     }
		     else
		     {
		             
		             int dimsize[64];//数组最大维数64
		             int i = 0;
		             int arraysize = op;//total size
		             dimsize[i] = op;
		             i++;
		             
		             while (m_pMainFunction->PopDigit(&op, &type1, &DT1))
		             {
		                     dimsize[i] = op;                        
		                     i++;
		                     arraysize *= op;
		             }
		
		             //如果是数组， 分配指针类型
		             long temp;
		             long index;
		             temp = AllocTempVar(type->type, 1);
		             if (temp == -1)
		             {
		                     GENERR(98);
		             }
		             //设置类型和名字
		             index = this->m_pMainFunction->m_SymbolTable.m_nSymbolCount -1;
		             strcpy(m_pMainFunction->m_SymbolTable.tableEntry[index].szName, szName);
		             type->dim = i-1;
		             type->refLevel = 1;
		             memcpy(type->dimsize, dimsize, (i-1)*sizeof(long));
		             memcpy(&m_pMainFunction->m_SymbolTable.tableEntry[index].type, type, sizeof(TYPEDES));
		             m_pMainFunction->m_iParamTotalSize += this->UnitSize(*type);
		     }
		
		     };
	}
# line 571 "cs.atg"
	
	//      printf("===>2\n");
	// allocate variable
	      if (type->type == dtGeneral){ // create object automatically if not type specified or type is dtGeneral
	//      printf("===>1\n");
	//      printf("--->m_pMainFunction1=%x, expStockPt=%x", m_pMainFunction, m_pMainFunction->m_pExpDigitPt);
	      if (!AllocVar(type, szName))
	                        GENERR(113);
	
	              m_pMainFunction->m_iParamTotalSize += this->UnitSize(*type);
	      }
	      delete type;
}

# line 588 "cs.atg"
void cParser::Statement()
{
# line 588 "cs.atg"
	debug("====>statement");
# line 589 "cs.atg"
	while (Sym == caseSym ||
	       Sym == defaultSym) {
# line 589 "cs.atg"
		Label();
	}
# line 597 "cs.atg"
	switch (Sym) {
		case identifierSym: 
		case numberSym: 
		case stringD1Sym: 
		case charD1Sym: 
		case LbraceSym: 
		case LparenSym: 
		case StarSym: 
		case AndSym: 
		case PlusSym: 
		case MinusSym: 
		case PlusPlusSym: 
		case MinusMinusSym: 
		case newSym: 
		case DollarSym: 
		case BangSym: 
		case TildeSym:  
# line 597 "cs.atg"
			AssignmentStatement();
			break;
		case breakSym:  
# line 597 "cs.atg"
			BreakStatement();
			break;
		case continueSym:  
# line 598 "cs.atg"
			ContinueStatement();
			break;
		case doSym:  
# line 599 "cs.atg"
			DoStatement();
			break;
		case forSym:  
# line 599 "cs.atg"
			ForStatement();
			break;
		case ifSym:  
# line 600 "cs.atg"
			IfStatement();
			break;
		case SemicolonSym:  
# line 600 "cs.atg"
			NullStatement();
			break;
		case returnSym:  
# line 601 "cs.atg"
			ReturnStatement();
			break;
		case switchSym:  
# line 601 "cs.atg"
			SwitchStatement();
			break;
		case whileSym:  
# line 602 "cs.atg"
			WhileStatement();
			break;
		default :GenError(94); break;
	}
# line 602 "cs.atg"
	        m_pMainFunction->ClearExpStack();
}

# line 605 "cs.atg"
void cParser::Label()
{
# line 605 "cs.atg"
	if (Sym == caseSym) {
# line 605 "cs.atg"
		Get();
# line 605 "cs.atg"
		ConstExpression();
# line 605 "cs.atg"
		Expect(ColonSym);
	} else if (Sym == defaultSym) {
# line 605 "cs.atg"
		Get();
# line 605 "cs.atg"
		Expect(ColonSym);
	} else GenError(95);
}

# line 610 "cs.atg"
void cParser::AssignmentStatement()
{
# line 610 "cs.atg"
	debug("===>AssignmentStatement1");
# line 610 "cs.atg"
	Expression();
# line 610 "cs.atg"
	Expect(SemicolonSym);
# line 610 "cs.atg"
	debug("===>AssignmentStatement2"); if (m_pMainFunction )m_pMainFunction->ClearExpStack();
}

# line 612 "cs.atg"
void cParser::BreakStatement()
{
# line 612 "cs.atg"
	Expect(breakSym);
# line 613 "cs.atg"
	        //recode this command for write back
	   this->m_curloop->AddBreak(this->m_pMainFunction->m_nCurrentCmdNum);
	   //add command
	   ADDCOMMAND1(__jmp, CC, 0);      
# line 618 "cs.atg"
	Expect(SemicolonSym);
# line 618 "cs.atg"
	if (m_pMainFunction )m_pMainFunction->ClearExpStack();
}

# line 644 "cs.atg"
void cParser::ContinueStatement()
{
# line 644 "cs.atg"
	Expect(continueSym);
# line 645 "cs.atg"
	
	    //recode this command for write back
	    this->m_curloop->AddContinue(this->m_pMainFunction->m_nCurrentCmdNum);
	    //add command
	    ADDCOMMAND1(__jmp, CC, 0);      
	
# line 652 "cs.atg"
	Expect(SemicolonSym);
# line 652 "cs.atg"
	        if (m_pMainFunction )m_pMainFunction->ClearExpStack();
}

# line 655 "cs.atg"
void cParser::DoStatement()
{
# line 655 "cs.atg"
	Expect(doSym);
# line 655 "cs.atg"
	Statement();
# line 655 "cs.atg"
	Expect(whileSym);
# line 655 "cs.atg"
	Expect(LparenSym);
# line 655 "cs.atg"
	Expression();
# line 655 "cs.atg"
	Expect(RparenSym);
# line 655 "cs.atg"
	Expect(SemicolonSym);
# line 655 "cs.atg"
	        if (m_pMainFunction )m_pMainFunction->ClearExpStack();
}

# line 657 "cs.atg"
void cParser::ForStatement()
{
# line 657 "cs.atg"
	Expect(forSym);
# line 657 "cs.atg"
	Expect(LparenSym);
# line 657 "cs.atg"
	if (Sym >= identifierSym && Sym <= numberSym ||
	    Sym >= stringD1Sym && Sym <= charD1Sym ||
	    Sym == LbraceSym ||
	    Sym == LparenSym ||
	    Sym == StarSym ||
	    Sym == AndSym ||
	    Sym >= PlusSym && Sym <= MinusSym ||
	    Sym >= PlusPlusSym && Sym <= MinusMinusSym ||
	    Sym >= newSym && Sym <= DollarSym ||
	    Sym >= BangSym && Sym <= TildeSym) {
# line 657 "cs.atg"
		Expression();
	}
# line 657 "cs.atg"
	Expect(SemicolonSym);
# line 658 "cs.atg"
	
	    //循环从下一句开始
	    int loopEntry = this->m_pMainFunction->m_nCurrentCmdNum;
	    int jzCmd = 0;
	    
	    //压栈
	    this->AddNewLoop();//添加一个新的looptree
	    this->m_curloop->m_entry = loopEntry;//设置新looptree的入口
	
	;
# line 669 "cs.atg"
	        if (m_pMainFunction )m_pMainFunction->ClearExpStack();
# line 670 "cs.atg"
	if (Sym >= identifierSym && Sym <= numberSym ||
	    Sym >= stringD1Sym && Sym <= charD1Sym ||
	    Sym == LbraceSym ||
	    Sym == LparenSym ||
	    Sym == StarSym ||
	    Sym == AndSym ||
	    Sym >= PlusSym && Sym <= MinusSym ||
	    Sym >= PlusPlusSym && Sym <= MinusMinusSym ||
	    Sym >= newSym && Sym <= DollarSym ||
	    Sym >= BangSym && Sym <= TildeSym) {
# line 670 "cs.atg"
		Expression();
	}
# line 671 "cs.atg"
	
	            //add command jz
	            jzCmd = this->m_pMainFunction->m_nCurrentCmdNum;
	            ADDCOMMAND1(__jnz, CC, 0)
	;
# line 677 "cs.atg"
	Expect(SemicolonSym);
# line 677 "cs.atg"
	        if (m_pMainFunction )m_pMainFunction->ClearExpStack();
# line 678 "cs.atg"
	
	    PCOMMAND cmd = NULL;
	    int cmdsaved;
	    int cmdnum;
	
	
# line 685 "cs.atg"
	if (Sym >= identifierSym && Sym <= numberSym ||
	    Sym >= stringD1Sym && Sym <= charD1Sym ||
	    Sym == LbraceSym ||
	    Sym == LparenSym ||
	    Sym == StarSym ||
	    Sym == AndSym ||
	    Sym >= PlusSym && Sym <= MinusSym ||
	    Sym >= PlusPlusSym && Sym <= MinusMinusSym ||
	    Sym >= newSym && Sym <= DollarSym ||
	    Sym >= BangSym && Sym <= TildeSym) {
# line 686 "cs.atg"
		
		              cmdsaved = this->m_pMainFunction->m_nCurrentCmdNum;
# line 689 "cs.atg"
		Expression();
# line 690 "cs.atg"
		
		              cmdnum = this->m_pMainFunction->m_nCurrentCmdNum - cmdsaved;
		              cmd = new COMMAND[cmdnum];    
		              //save expression cmd to insert before jmp command
		              long t=cmdnum*sizeof(COMMAND);
		              memcpy(cmd, &(m_pMainFunction->m_pCmdTable[cmdsaved]), cmdnum*sizeof(COMMAND));
		              m_pMainFunction->m_nCurrentCmdNum = cmdsaved;           
		
	}
# line 699 "cs.atg"
	Expect(RparenSym);
# line 699 "cs.atg"
	Statement();
# line 700 "cs.atg"
	
	    long nContinue;//continue 语句的跳转目的地。
	    nContinue = this->m_pMainFunction->m_nCurrentCmdNum;
	    this->m_curloop->SetContinue(nContinue);
	
	    //insert saved cmd
	    for (int i = 0; i< cmdnum; i++)
	    {
	            m_pMainFunction->AddCommand(cmd[i]);
	    }
	    delete cmd;
	    //change loop variable
	    //jump back
	    ADDCOMMAND1(__jmp, CC, loopEntry);      
	    //write back jz instructment
	    this->m_pMainFunction->m_pCmdTable[jzCmd].op[0] = this->m_pMainFunction->m_nCurrentCmdNum;
	    //write back break continue statement
	    this->m_curloop->SetExit(this->m_pMainFunction->m_nCurrentCmdNum);
	    this->ExitCurLoop();//destroy current loop tree
	;
}

# line 722 "cs.atg"
void cParser::IfStatement()
{
# line 722 "cs.atg"
	Expect(ifSym);
# line 722 "cs.atg"
	Expect(LparenSym);
# line 722 "cs.atg"
	Expression();
# line 722 "cs.atg"
	Expect(RparenSym);
# line 723 "cs.atg"
	
	    //判断
	    {
	            long op1;
	            long type1;
	            TYPEDES dt1;
	            //pop
	            if (!m_pMainFunction->PopDigit(&op1, &type1, &dt1) || type1 <FIRST_ADDRESS_MODE || type1 >LAST_ADDRESS_MODE) 
	            {
	                    //      REPORT_COMPILE_ERROR("POP UP FAILED");
	                    GENERR(96);
	                    return;
	            }
	            else
	            {
	                    if (dt1.type == dtFloat)
	                    {
	                            GENERR(112);
	                    }
	                    else
	                    {
	                            //get address mode
	                            int address_mode = (type1<<8);
	                            address_mode |= (log2(UnitSize(dt1))<<14)|(log2(UnitSize(dt1))<<6);     
	                            address_mode |= AMODE_DIRECT;
	                            //add commmand to command table
	                            ADDCOMMAND3(__test, address_mode, op1, 0, 0)    
	                    }
	            }
	    }
	
	    //记录跳转指令的序号
	    int jzcmd = this->m_pMainFunction->m_nCurrentCmdNum;
	    //加入判断语句
	    ADDCOMMAND1(__jz, CC, 0)//跳转目标在下面补上;
# line 759 "cs.atg"
	Statement();
# line 759 "cs.atg"
	        int nextcmd; bool bElse = false;
# line 759 "cs.atg"
	if (Sym == elseSym) {
# line 761 "cs.atg"
		Get();
# line 762 "cs.atg"
		
		            bElse = true;
		            int jmpcmd = this->m_pMainFunction->m_nCurrentCmdNum;
		            ADDCOMMAND1(__jmp, CC, 0);
		            //补上jnz的跳转目标
		            nextcmd = this->m_pMainFunction->m_nCurrentCmdNum;
		            this->m_pMainFunction->m_pCmdTable[jzcmd].op[0] = nextcmd;
		
# line 771 "cs.atg"
		Statement();
# line 772 "cs.atg"
		
		            nextcmd = this->m_pMainFunction->m_nCurrentCmdNum;
		            //补上jmp的跳转目标
		            this->m_pMainFunction->m_pCmdTable[jmpcmd].op[0] = nextcmd;
		
	}
# line 779 "cs.atg"
	
	if (!bElse)
	{
	           //补上jnz的跳转目标
	           nextcmd = this->m_pMainFunction->m_nCurrentCmdNum;
	           this->m_pMainFunction->m_pCmdTable[jzcmd].op[0] = nextcmd;
	   };
}

# line 789 "cs.atg"
void cParser::NullStatement()
{
# line 789 "cs.atg"
	Expect(SemicolonSym);
# line 789 "cs.atg"
	        if (m_pMainFunction )m_pMainFunction->ClearExpStack();
}

# line 791 "cs.atg"
void cParser::ReturnStatement()
{
# line 791 "cs.atg"
	Expect(returnSym);
# line 791 "cs.atg"
	if (Sym >= identifierSym && Sym <= numberSym ||
	    Sym >= stringD1Sym && Sym <= charD1Sym ||
	    Sym == LbraceSym ||
	    Sym == LparenSym ||
	    Sym == StarSym ||
	    Sym == AndSym ||
	    Sym >= PlusSym && Sym <= MinusSym ||
	    Sym >= PlusPlusSym && Sym <= MinusMinusSym ||
	    Sym >= newSym && Sym <= DollarSym ||
	    Sym >= BangSym && Sym <= TildeSym) {
# line 791 "cs.atg"
		Expression();
	}
# line 792 "cs.atg"
	
	    //pop
	    long op1;
	    long type;
	    TYPEDES dt1;
	    if (!m_pMainFunction->PopDigit(&op1, &type, &dt1)|| type <FIRST_ADDRESS_MODE || type >LAST_ADDRESS_MODE )
	    {
	    //      REPORT_COMPILE_ERROR("POP UP FAILED");
	            GENERR(96);
	            return;
	    }
	    int address_mode = type&0x00ff;
	    address_mode |= (log2(UnitSize(dt1))<<6);
	    
	    //ADDCOMMAND
	    // move reutrn value to _ax
	    ADDCOMMAND2(__mov, address_mode|0x8200, _AX, op1);
	    // return
	    ADDCOMMAND0(__ret);
	
# line 813 "cs.atg"
	Expect(SemicolonSym);
# line 813 "cs.atg"
	        if (m_pMainFunction )m_pMainFunction->ClearExpStack();
}

# line 816 "cs.atg"
void cParser::SwitchStatement()
{
# line 816 "cs.atg"
	Expect(switchSym);
# line 816 "cs.atg"
	Expect(LparenSym);
# line 818 "cs.atg"
	Expression();
# line 821 "cs.atg"
	Expect(RparenSym);
# line 821 "cs.atg"
	Statement();
}

# line 825 "cs.atg"
void cParser::WhileStatement()
{
# line 825 "cs.atg"
	Expect(whileSym);
# line 825 "cs.atg"
	Expect(LparenSym);
# line 826 "cs.atg"
	
	  int loopentry = this->m_pMainFunction->m_nCurrentCmdNum;
	
	  //压栈
	  this->AddNewLoop();//添加一个新的looptree
	  this->m_curloop->m_entry = loopentry;//设置新looptree的入口
	
	;
# line 835 "cs.atg"
	Expression();
# line 836 "cs.atg"
	
	//判断
	{
	   long op1;
	   long type1;
	   TYPEDES dt1;
	   //pop
	   if (!m_pMainFunction->PopDigit(&op1, &type1, &dt1) || type1 <FIRST_ADDRESS_MODE || type1 >LAST_ADDRESS_MODE) 
	   {
	           //      REPORT_COMPILE_ERROR("POP UP FAILED");
	           GENERR(96);
	           return;
	   }
	   else
	   {
	           if (dt1.type == dtFloat)
	           {
	                   GENERR(112);
	           }
	           else
	           {
	                   //get address mode
	                   int address_mode = (type1<<8);
	                   address_mode |= (log2(UnitSize(dt1))<<14)|(log2(UnitSize(dt1))<<6);     
	                   address_mode |= AMODE_DIRECT;
	                   //add commmand to command table
	                   ADDCOMMAND3(__test, address_mode, op1, 0, 0)    
	           }
	   }
	}
	
	int jnzCmd =  this->m_pMainFunction->m_nCurrentCmdNum;
	//jnz command
	ADDCOMMAND1(__jz, CC, 0);
# line 871 "cs.atg"
	Expect(RparenSym);
# line 871 "cs.atg"
	Statement();
# line 873 "cs.atg"
	
	 long nContinue;//continue 语句的跳转目的地。
	 nContinue = this->m_pMainFunction->m_nCurrentCmdNum;
	 this->m_curloop->SetContinue(nContinue);
	
	 //jmp back
	 ADDCOMMAND1(__jmp, CC, loopentry);
	 //write back jnz
	 this->m_pMainFunction->m_pCmdTable[jnzCmd].op[0] = this->m_pMainFunction->m_nCurrentCmdNum;
	
	 this->m_curloop->SetExit(this->m_pMainFunction->m_nCurrentCmdNum);
	 this->ExitCurLoop();//destroy current loop tree
	;
}

# line 620 "cs.atg"
void cParser::LocalDeclaration()
{
# line 621 "cs.atg"
	
	debug("===>LocalDeclaration");
	      PTYPEDES type = new TYPEDES;
	      char szName[MAX_IDENTIFIER_LENGTH];
	      
	
# line 627 "cs.atg"
	if (Sym >= varSym && Sym <= stringSym) {
# line 627 "cs.atg"
		Type(type);
	} else if (Sym >= staticSym && Sym <= functionSym) {
# line 627 "cs.atg"
		StorageClass();
# line 627 "cs.atg"
		if (Sym >= varSym && Sym <= stringSym) {
# line 627 "cs.atg"
			Type(type);
		}
	} else GenError(96);
# line 630 "cs.atg"
	while (Sym == StarSym) {
# line 630 "cs.atg"
		Get();
# line 630 "cs.atg"
		                type->refLevel++;
	}
# line 633 "cs.atg"
	Expect(identifierSym);
# line 633 "cs.atg"
	        
	                      memset(szName, 0, MAX_IDENTIFIER_LENGTH);
	                      Scanner->GetName(&Scanner->CurrSym, szName, MAX_IDENTIFIER_LENGTH-1);
	              
# line 637 "cs.atg"
	if (Sym == LparenSym) {
# line 637 "cs.atg"
		FunctionDefinition();
	} else if (Sym == SemicolonSym ||
	           Sym >= EqualSym && Sym <= LbrackSym) {
# line 637 "cs.atg"
		VarList(type, szName);
# line 637 "cs.atg"
		Expect(SemicolonSym);
	} else GenError(97);
# line 637 "cs.atg"
	delete type; if (m_pMainFunction )m_pMainFunction->ClearExpStack();
}

# line 924 "cs.atg"
void cParser::Conditional()
{
# line 924 "cs.atg"
	LogORExp();
}

# line 2627 "cs.atg"
void cParser::AssignmentOperator()
{
# line 2627 "cs.atg"
	switch (Sym) {
		case EqualSym:  
# line 2627 "cs.atg"
			Get();
			break;
		case StarEqualSym:  
# line 2627 "cs.atg"
			Get();
			break;
		case SlashEqualSym:  
# line 2627 "cs.atg"
			Get();
			break;
		case PercentEqualSym:  
# line 2627 "cs.atg"
			Get();
			break;
		case PlusEqualSym:  
# line 2627 "cs.atg"
			Get();
			break;
		case MinusEqualSym:  
# line 2627 "cs.atg"
			Get();
			break;
		case AndEqualSym:  
# line 2627 "cs.atg"
			Get();
			break;
		case UparrowEqualSym:  
# line 2628 "cs.atg"
			Get();
			break;
		case BarEqualSym:  
# line 2628 "cs.atg"
			Get();
			break;
		case LessLessEqualSym:  
# line 2628 "cs.atg"
			Get();
			break;
		case GreaterGreaterEqualSym:  
# line 2628 "cs.atg"
			Get();
			break;
		default :GenError(98); break;
	}
}

# line 926 "cs.atg"
void cParser::LogORExp()
{
# line 926 "cs.atg"
	LogANDExp();
# line 926 "cs.atg"
	        int type = -1;
# line 926 "cs.atg"
	while (Sym == BarBarSym) {
# line 926 "cs.atg"
		Get();
# line 928 "cs.atg"
		
		            type = 7;
# line 931 "cs.atg"
		LogANDExp();
# line 932 "cs.atg"
		
		              //add command
		              long op1, op2;
		              long type1, type2;
		              TYPEDES dt1, dt2;
		              //pop出乘数和被乘数
		              if (!m_pMainFunction->PopDigit(&op2, &type2, &dt2) || !m_pMainFunction->PopDigit(&op1, &type1, &dt1) || type1 <FIRST_ADDRESS_MODE || type1 >LAST_ADDRESS_MODE || type2 <FIRST_ADDRESS_MODE || type2 >LAST_ADDRESS_MODE)
		              {
		              //      REPORT_COMPILE_ERROR("POP UP FAILED");
		                      GENERR(96);
		                      return;
		              }
		              else
		              {
		                      CAST
		                      //get address mode
		                      int address_mode = (type1<<8)|(short)type2;
		                      address_mode |= (log2(UnitSize(dt1))<<14)|(log2(UnitSize(dt2))<<6);
		                      //add commmand to command table
		                      ADDCOMMAND3(__test, address_mode, op1, op2, 7/*==*/)                                    
		                      //push result
		                      TYPEDES dt;//not used
		                      memset(&dt, 0, sizeof(TYPEDES));
		                      this->m_pMainFunction->PushDigit(_PSW, 0x82, dt);
		              };
	}
# line 960 "cs.atg"
	
	      if (type >= 0)
	      {
	              long g;
	              long t;
	              TYPEDES DT;
	              m_pMainFunction->PopDigit(&g, &t, &DT);
	              //将结果存入临时变量
	              
	              _typedes(DT1, dtLong)
	              if (m_pMainFunction->AddVal(NULL, DT1))
	              {
	                      long temp;
	                      temp = m_pMainFunction->m_SymbolTable.tableEntry[m_pMainFunction->m_SymbolTable.m_nSymbolCount-1].address;
	                      ADDCOMMAND2(__mov, DR, temp, _PSW);
	                      m_pMainFunction->PushDigit(temp, AMODE_MEM|0x80, DT1);
	              }
	              else
	              {
	                      REPORT_COMPILE_ERROR("add symbol failed");
	              }
	      };
}

# line 985 "cs.atg"
void cParser::LogANDExp()
{
# line 986 "cs.atg"
	        
	int type = -1;
	    long op1, op2;
	    long type1, type2;
	    TYPEDES dt1, dt2;
# line 993 "cs.atg"
	InclORExp();
# line 993 "cs.atg"
	while (Sym == AndAndSym) {
# line 993 "cs.atg"
		Get();
# line 995 "cs.atg"
		                type = 7;
# line 997 "cs.atg"
		InclORExp();
# line 999 "cs.atg"
		
		              //add command
		              //pop出乘数和被乘数
		              if (!m_pMainFunction->PopDigit(&op2, &type2, &dt2) || !m_pMainFunction->PopDigit(&op1, &type1, &dt1) || type1 <FIRST_ADDRESS_MODE || type1 >LAST_ADDRESS_MODE || type2 <FIRST_ADDRESS_MODE || type2 >LAST_ADDRESS_MODE)
		              {
		              //      REPORT_COMPILE_ERROR("POP UP FAILED");
		                      GENERR(96);
		                      return;
		              }
		              else
		              {
		                      CAST
		                      //get address mode
		                      int address_mode = (type1<<8)|(short)type2;
		                      address_mode |= (log2(UnitSize(dt1))<<14)|(log2(UnitSize(dt2))<<6);
		                      //add commmand to command table
		                      ADDCOMMAND3(__test, address_mode, op1, op2, 6/*==*/)                                    
		                      //push result
		                      TYPEDES dt;//not used
		                      memset(&dt, 0, sizeof(TYPEDES));
		                      this->m_pMainFunction->PushDigit(_PSW, 0x82, dt);
		              }
		;
	}
# line 1024 "cs.atg"
	
	      if (type >= 0)
	      {
	              long g;
	              long t;
	              TYPEDES dt;
	              m_pMainFunction->PopDigit(&g, &t, &dt);
	              
	              //将结果存入临时变量
	              if (m_pMainFunction->AddVal(NULL, dt1))
	              {                       
	                      long temp;
	                      temp = m_pMainFunction->m_SymbolTable.tableEntry[m_pMainFunction->m_SymbolTable.m_nSymbolCount-1].address;
	                      ADDCOMMAND2(__mov, DR, temp, _PSW);
	                      m_pMainFunction->PushDigit(temp, AMODE_MEM|0x80, dt1);
	              }
	              else
	              {
	                      REPORT_COMPILE_ERROR("add symbol failed");
	              }
	              };
}

# line 1048 "cs.atg"
void cParser::InclORExp()
{
# line 1048 "cs.atg"
	ExclORExp();
# line 1048 "cs.atg"
	while (Sym == BarSym) {
# line 1048 "cs.atg"
		Get();
# line 1048 "cs.atg"
		ExclORExp();
	}
}

# line 1050 "cs.atg"
void cParser::ExclORExp()
{
# line 1050 "cs.atg"
	ANDExp();
# line 1050 "cs.atg"
	while (Sym == UparrowSym) {
# line 1050 "cs.atg"
		Get();
# line 1050 "cs.atg"
		ANDExp();
	}
}

# line 1052 "cs.atg"
void cParser::ANDExp()
{
# line 1052 "cs.atg"
	EqualExp();
# line 1052 "cs.atg"
	while (Sym == AndSym) {
# line 1052 "cs.atg"
		Get();
# line 1052 "cs.atg"
		EqualExp();
	}
}

# line 1054 "cs.atg"
void cParser::EqualExp()
{
# line 1055 "cs.atg"
	
	    int type = -1;//0: == 1: !=
	    long op1, op2;
	    long type1, type2;
	    TYPEDES dt1, dt2;
	
# line 1063 "cs.atg"
	RelationExp();
# line 1063 "cs.atg"
	while (Sym >= EqualEqualSym && Sym <= BangEqualSym) {
# line 1065 "cs.atg"
		if (Sym == EqualEqualSym) {
# line 1063 "cs.atg"
			Get();
# line 1064 "cs.atg"
			                        type = 0;
		} else if (Sym == BangEqualSym) {
# line 1065 "cs.atg"
			Get();
# line 1066 "cs.atg"
			
			                      type = 1;
			
		} else GenError(99);
# line 1069 "cs.atg"
		RelationExp();
# line 1071 "cs.atg"
		
		              //add command
		              //pop出乘数和被乘数
		              if (!m_pMainFunction->PopDigit(&op2, &type2, &dt2) || !m_pMainFunction->PopDigit(&op1, &type1, &dt1) || type2 <FIRST_ADDRESS_MODE || type2 >LAST_ADDRESS_MODE)
		              {
		              //      REPORT_COMPILE_ERROR("POP UP FAILED");
		                      GENERR(96);
		                      return;
		              }
		              else
		              {
		                      CAST
		                      //get address mode
		                      int address_mode = (type1<<8)|(short)type2;
		                      address_mode |= (log2(UnitSize(dt1))<<14)|(log2(UnitSize(dt2))<<6);
		
		                      //add commmand to command table
		                      if (type == 0)
		                      {       
		                              ADDCOMMAND3(__test, address_mode, op1, op2, 0/*==*/)                                    
		                      }
		                      else if (type == 1)
		                      {
		                              ADDCOMMAND3(__test, address_mode, op1, op2, 1/*==*/)    
		                      }
		
		                      //push result
		                      TYPEDES dt;//not used
		                      memset(&dt, 0, sizeof(TYPEDES));
		                      this->m_pMainFunction->PushDigit(_PSW, 0x82, dt);
		              }
		;
	}
# line 1106 "cs.atg"
	
	      if (type >= 0)
	      {
	              long g;
	              long t;
	              TYPEDES dt;
	              if (m_pMainFunction->PopDigit(&g, &t, &dt))
	              {
	                      //将结果存入临时变量
	                      if (m_pMainFunction->AddVal(NULL,  dt1))
	                      {                       
	                              long temp;
	                              temp = m_pMainFunction->m_SymbolTable.tableEntry[m_pMainFunction->m_SymbolTable.m_nSymbolCount-1].address;
	                              ADDCOMMAND2(__mov, DR, temp , _PSW);
	                              m_pMainFunction->PushDigit(temp, AMODE_MEM|0x80, dt1);
	                      }
	                      else
	                      {
	                              REPORT_COMPILE_ERROR("add symbol failed");
	                      }
	              }
	      };
}

# line 1131 "cs.atg"
void cParser::RelationExp()
{
# line 1132 "cs.atg"
	
	    int type = -1;
	    long op1, op2;
	    long type1, type2;
	    TYPEDES dt1, dt2;
	
# line 1139 "cs.atg"
	ShiftExp();
# line 1139 "cs.atg"
	while (Sym == LessSym ||
	       Sym >= GreaterSym && Sym <= GreaterEqualSym) {
# line 1139 "cs.atg"
		switch (Sym) {
			case LessSym:  
# line 1139 "cs.atg"
				Get();
# line 1139 "cs.atg"
				type = 5;
				break;
			case GreaterSym:  
# line 1139 "cs.atg"
				Get();
# line 1139 "cs.atg"
				type = 4;
				break;
			case LessEqualSym:  
# line 1139 "cs.atg"
				Get();
# line 1139 "cs.atg"
				type = 3;
				break;
			case GreaterEqualSym:  
# line 1139 "cs.atg"
				Get();
# line 1139 "cs.atg"
				type = 2;
				break;
			default :GenError(100); break;
		}
# line 1140 "cs.atg"
		ShiftExp();
# line 1142 "cs.atg"
		
		            //add command
		            //pop出乘数和被乘数
		            if (!m_pMainFunction->PopDigit(&op2, &type2, &dt2) || !m_pMainFunction->PopDigit(&op1, &type1, &dt1) || type2 <FIRST_ADDRESS_MODE || type2 >LAST_ADDRESS_MODE)
		            {
		            //      REPORT_COMPILE_ERROR("POP UP FAILED");
		                    GENERR(96);
		                    return;
		            }
		            else
		            {
		                    CAST
		                    //get address mode
		                    int address_mode = (type1<<8)|(short)type2;
		                    address_mode |= (log2(UnitSize(dt1))<<14)|(log2(UnitSize(dt2))<<6);
		
		                    //add commmand to command table
		                    ADDCOMMAND3(__test, address_mode, op1, op2, type)                                       
		
		                    //push result
		                    TYPEDES dt;//not used
		                    memset(&dt, 0, sizeof(TYPEDES));
		                    this->m_pMainFunction->PushDigit(_PSW, 0x82, dt);
		            }
		
		;
	}
# line 1171 "cs.atg"
	
	    if (type >= 0)
	    {
	            // pop掉多于的操作数, 因为这时结果已在__AX中
	            long g;
	            long t;
	            TYPEDES dt;
	            m_pMainFunction->PopDigit(&g, &t, &dt);
	
	            //将结果存入临时变量
	            _typedes(dt_temp, dtLong)
	            if (m_pMainFunction->AddVal(NULL,  dt_temp))
	            {                       
	                    long temp;
	                    temp = m_pMainFunction->m_SymbolTable.tableEntry[m_pMainFunction->m_SymbolTable.m_nSymbolCount-1].address;
	                    ADDCOMMAND2(__mov, DR, temp, _PSW);
	                    m_pMainFunction->PushDigit(temp, AMODE_MEM|0x80, dt_temp);
	            }
	            else
	            {
	                    REPORT_COMPILE_ERROR("add symbol failed");
	            }
	    };
}

# line 1197 "cs.atg"
void cParser::ShiftExp()
{
# line 1197 "cs.atg"
	AddExp();
# line 1197 "cs.atg"
	while (Sym >= LessLessSym && Sym <= GreaterGreaterSym) {
# line 1197 "cs.atg"
		if (Sym == LessLessSym) {
# line 1197 "cs.atg"
			Get();
		} else if (Sym == GreaterGreaterSym) {
# line 1197 "cs.atg"
			Get();
		} else GenError(101);
# line 1197 "cs.atg"
		AddExp();
	}
}

# line 1199 "cs.atg"
void cParser::AddExp()
{
# line 1199 "cs.atg"
	        int type = -1;//1: add 0: sub;
# line 1200 "cs.atg"
	MultExp();
# line 1200 "cs.atg"
	while (Sym >= PlusSym && Sym <= MinusSym) {
# line 1200 "cs.atg"
		if (Sym == PlusSym) {
# line 1200 "cs.atg"
			Get();
# line 1200 "cs.atg"
			        type = 1;
		} else if (Sym == MinusSym) {
# line 1200 "cs.atg"
			Get();
# line 1200 "cs.atg"
			type = 0;
		} else GenError(102);
# line 1200 "cs.atg"
		MultExp();
# line 1202 "cs.atg"
		
		              //add command
		              long op1, op2;
		              long type1, type2;
		              TYPEDES dt1, dt2;
		              //pop出乘数和被乘数
		              if (!m_pMainFunction->PopDigit(&op2, &type2, &dt2) || !m_pMainFunction->PopDigit(&op1, &type1, &dt1) || type1 <FIRST_ADDRESS_MODE || type1 >LAST_ADDRESS_MODE || type2 <FIRST_ADDRESS_MODE || type2 >LAST_ADDRESS_MODE)
		              {
		              //      REPORT_COMPILE_ERROR("POP UP FAILED");
		                      GENERR(96);
		                      return;
		              }
		              else
		              {
		
		                      //类型转换
		                      CAST
		                      //get address mode
		                      int address_mode = (type1<<8)|(short)type2;
		                      address_mode |= (log2(UnitSize(dt1))<<14)|(log2(UnitSize(dt2))<<6);
		
		                      
		                      if (dt1.dim >0)
		                      {//如果是数组变量
		                              //得到增量
		                              int size = UnitSize(dt1);
		                              for (int i=1; i<dt1.dim;i++)
		                              {
		                                      size *= dt1.dimsize[i];
		                              }
		                              //增量乘以op2得到实际增量,存入_AX
		                              ADDCOMMAND2(__mul, type2<<8, op2, size)
		                              //加法
		                              if (dt1.type == dtFloat && dt1.refLevel==0)
		                              {
		                                      if (type == 0)
		                                      ADDCOMMAND2(__fsub, (type1<<8)|0x82, op1, _AX)  
		                                      else if (type == 1)
		                                      ADDCOMMAND2(__fadd, (type1<<8)|0x82, op1, _AX)  
		                              }
		                              else
		                              {
		                                      if (type == 0)
		                                      ADDCOMMAND2(__sub, (type1<<8)|0x82, op1, _AX)   
		                                      else if (type == 1)
		                                      ADDCOMMAND2(__add, (type1<<8)|0x82, op1, _AX)   
		                              }
		                      }
		                      else
		                      {
		                              //add commmand to command table
		                              if (dt1.type == dtFloat && dt1.refLevel==0)
		                              {
		                                      if (type == 0)
		                                      ADDCOMMAND2(__fsub, address_mode, op1, op2)     
		                                      else if (type == 1)
		                                      ADDCOMMAND2(__fadd, address_mode, op1, op2)     
		                              }
		                              else
		                              {
		                                      if (type == 0)
		                                      ADDCOMMAND2(__sub, address_mode, op1, op2)      
		                                      else if (type == 1)
		                                      ADDCOMMAND2(__add, address_mode, op1, op2)      
		                              }
		                      }       
		                      //将AX中的结果存入临时变量
		                      if (m_pMainFunction->AddVal(NULL,  dt1))
		                      {                       
		                              long temp;
		                              long opsize = log2(UnitSize(dt1))<<6;
		                              temp = m_pMainFunction->m_SymbolTable.tableEntry[m_pMainFunction->m_SymbolTable.m_nSymbolCount-1].address;
		                              ADDCOMMAND2(__mov, DR|((opsize<<8)|opsize), temp , _AX);
		                              m_pMainFunction->PushDigit(temp, AMODE_MEM|opsize, dt1);
		                      }
		                      else
		                      {
		                              REPORT_COMPILE_ERROR("add symbol failed");
		                      }
		              };
	}
}

# line 1286 "cs.atg"
void cParser::MultExp()
{
# line 1286 "cs.atg"
	        char szName[MAX_IDENTIFIER_LENGTH];     memset(szName, 0, MAX_IDENTIFIER_LENGTH);
# line 1287 "cs.atg"
	CastExp();
# line 1288 "cs.atg"
	
	     Scanner->GetName(&Scanner->CurrSym, szName, MAX_IDENTIFIER_LENGTH-1);//得到名称
	     int type = -1;//0: mult 1: div 2:percent;
# line 1291 "cs.atg"
	while (Sym == StarSym ||
	       Sym >= SlashSym && Sym <= PercentSym) {
# line 1291 "cs.atg"
		if (Sym == StarSym) {
# line 1291 "cs.atg"
			Get();
# line 1291 "cs.atg"
			        type = 0;
		} else if (Sym == SlashSym) {
# line 1291 "cs.atg"
			Get();
# line 1291 "cs.atg"
			        type = 1;
		} else if (Sym == PercentSym) {
# line 1291 "cs.atg"
			Get();
# line 1291 "cs.atg"
			        type = 2;
		} else GenError(103);
# line 1291 "cs.atg"
		CastExp();
# line 1292 "cs.atg"
		
		              Scanner->GetName(&Scanner->CurrSym, szName, MAX_IDENTIFIER_LENGTH-1);//得到名称
		              
		              //add command
		              long op1, op2;
		              long type1, type2;
		              TYPEDES dt1, dt2;
		
		              //pop出乘数和被乘数
		              if (!m_pMainFunction->PopDigit(&op2, &type2, &dt2) || !m_pMainFunction->PopDigit(&op1, &type1, &dt1) ||type1 <FIRST_ADDRESS_MODE || type1 >LAST_ADDRESS_MODE || type2 <FIRST_ADDRESS_MODE || type2 >LAST_ADDRESS_MODE)
		              {
		                      //      REPORT_COMPILE_ERROR("POP UP FAILED");
		                      GENERR(96);
		                      return;
		              }
		              else
		              {
		                      CAST
		                      //get address mode
		                      int address_mode = (type1<<8)|(short)type2;
		                      address_mode |= (log2(UnitSize(dt1))<<14)|(log2(UnitSize(dt2))<<6);
		                      //add commmand to command table
		                      if (dt1.type == dtFloat && dt1.refLevel==0)
		                      {
		                              if (type == 0) ADDCOMMAND2(__fmul, address_mode, op1, op2)                                      
		                                      else if (type == 1) ADDCOMMAND2(__fdiv, address_mode, op1, op2)                                 
		                                      else GENERR(109);
		                      }
		                      else
		                      {
		                              if (type == 0) ADDCOMMAND2(__mul, address_mode, op1, op2)                                       
		                                      else if (type == 1) ADDCOMMAND2(__div, address_mode, op1, op2)
		                                      else if (type == 2) ADDCOMMAND2(__mod, address_mode, op1, op2)
		                      }
		                      
		                      //将AX中的结果存入临时变量
		                      if (m_pMainFunction->AddVal(NULL, dt1))
		                      {                       
		                              long temp;
		                              long opsize = log2(UnitSize(dt1))<<6;
		                              temp = m_pMainFunction->m_SymbolTable.tableEntry[m_pMainFunction->m_SymbolTable.m_nSymbolCount-1].address;
		                              ADDCOMMAND2(__mov, DR|((opsize<<8)|opsize), temp, _AX);
		                              m_pMainFunction->PushDigit(temp, AMODE_MEM|opsize, dt1);
		                      }
		                      else
		                      {
		                              GENERR(98);
		                      }
		              }
		;
	}
}

# line 1345 "cs.atg"
void cParser::CastExp()
{
# line 1345 "cs.atg"
	debug("===>CastExp");
# line 1346 "cs.atg"
	
	    //保存一元操作符栈
	    EXPRESSIONOP* pSavedStack = this->m_pExpOpPt;
	    //清空一元操作符栈
	    m_pExpOpPt = &m_ExpOp;
	    //int op;
	
# line 1354 "cs.atg"
	UnaryExp();
# line 1356 "cs.atg"
	
	    int op;
	    while (this->PopOp(&op))
	    {               
	
	            //操作数出栈
	            long op1;
	            long type1;
	            TYPEDES dt1;    
	            if (!m_pMainFunction->PopDigit(&op1, &type1, &dt1) ||type1 <FIRST_ADDRESS_MODE || type1 >LAST_ADDRESS_MODE)
	            {
	                    break;//GENERR(96);
	            }
	            int address_mode = (type1<<8);
	            address_mode |= log2(UnitSize(dt1))<<14;
	            
	            //添加命令
	            switch (op)
	            {
	            case PlusSym:                           
	                    //no operation
	                    break;
	            case MinusSym:                  
	                    {
	                            int opsize;
	                            if (!m_pMainFunction->AddVal(NULL, dt1))
	                                    GENERR(98);
	                            if (dt1.type == dtFloat)
	                            {
	                                    opsize = (type1>>6)&0xc0;
	                                    ADDCOMMAND2(__fsub, type1, 0, op1)
	                            }
	                            else
	                            {
	                                    opsize = (type1>>6)&0xc0;
	                                    ADDCOMMAND2(__sub, type1, 0, op1)
	                            }
	                            ADDCOMMAND2(__mov, DR, m_pMainFunction->m_SymbolTable.tableEntry[m_pMainFunction->m_SymbolTable.m_nSymbolCount -1].address, _AX)
	                            m_pMainFunction->PushDigit(m_pMainFunction->m_SymbolTable.tableEntry[m_pMainFunction->m_SymbolTable.m_nSymbolCount -1].address, AMODE_MEM|(opsize<<6), dt1);
	                    }
	                    break;
	            case StarSym:  
	                    {
	                            if (dt1.refLevel <1)
	                                    GENERR(102);
	                            dt1.refLevel--;
	                            //取操作的字节类型
	                            int opsize = log2(UnitSize(dt1));
	                            opsize = opsize<< 6;
	                            type1 |= opsize; 
	
	                            //将type1的间接访问级别提高一级
	                            int level = (type1 & 0x30) >> 4;
	                            if (level == 3)
	                            {
	                                    GENERR(103);
	                                    break;
	                            }
	                            level ++;
	                            type1 |= level << 4;
	/*                              int j = (type1>>4)&0x3;
	                            if (j < 1)
	                                    GENERR(102);//is not a point
	                            else
	                                    j--;
	                            j = j << 4;
	*/                              
	/*                      
	                            type1 &= 0xffcf;
	                            type1 |= j;
	*/
	                            //入栈
	                            m_pMainFunction->PushDigit(op1, type1, dt1);
	                    }
	                    break;
	            case BangSym: 
	                    {
	                            if (!m_pMainFunction->AddVal(NULL, dt1))
	                                    GENERR(98);
	                            int opsize = (type1>>6)&0x03;
	                            ADDCOMMAND2(__mov, (0x100|(opsize<<14))|(type1), m_pMainFunction->m_SymbolTable.tableEntry[m_pMainFunction->m_SymbolTable.m_nSymbolCount -1].address, op1)
	                            ADDCOMMAND1(__notr, type1<<8, m_pMainFunction->m_SymbolTable.tableEntry[m_pMainFunction->m_SymbolTable.m_nSymbolCount -1].address)
	                            m_pMainFunction->PushDigit(m_pMainFunction->m_SymbolTable.tableEntry[m_pMainFunction->m_SymbolTable.m_nSymbolCount -1].address, type1, dt1);
	                    }
	                    break;
	            case AndSym:  // & 取地址操作符
	                    {
	                            long temp;
	                            temp = AllocTempVar(dtLong, 1);
	                            if (temp == -1)
	                            {
	                                    GENERR(98);
	                            }
	                            else
	                            {
	                                    if (dt1.objID > 0)
	                                    {//如果时obj， 不取地址
	                                            m_pMainFunction->PushDigit(op1, type1, dt1);
	                                    }
	                                    else
	                                    {
	                                            ADDCOMMAND2(__ea, 0x8100|type1, temp, op1)
	                                            dt1.refLevel ++;
	                                            m_pMainFunction->PushDigit(temp, AMODE_MEM|0x80, dt1);
	                                    }
	                            }
	                    }
	                    break;
	            case TildeSym: //"~"
	                    {
	                            if (!m_pMainFunction->AddVal(NULL, dt1))
	                                    GENERR(98);
	                            int opsize = (type1>>6)&0xc0;
	                            ADDCOMMAND2(__mov, (0x100|(opsize<<14))|(type1), m_pMainFunction->m_SymbolTable.tableEntry[m_pMainFunction->m_SymbolTable.m_nSymbolCount -1].address, op1)
	                            ADDCOMMAND1(__not, type1<<8, m_pMainFunction->m_SymbolTable.tableEntry[m_pMainFunction->m_SymbolTable.m_nSymbolCount -1].address)
	                            m_pMainFunction->PushDigit(m_pMainFunction->m_SymbolTable.tableEntry[m_pMainFunction->m_SymbolTable.m_nSymbolCount -1].address, type1, dt1);
	                    }
	                    break;
	            default :GENERR(93); break;
	            }               
	    }
	    //恢复一元运算符栈
	    this->ClearOpStack();
	    m_pExpOpPt = pSavedStack;  
}

# line 1487 "cs.atg"
void cParser::UnaryExp()
{
# line 1487 "cs.atg"
	debug("===>UnaryExp");
# line 1488 "cs.atg"
	if (Sym >= identifierSym && Sym <= numberSym ||
	    Sym >= stringD1Sym && Sym <= charD1Sym ||
	    Sym == LbraceSym ||
	    Sym == LparenSym ||
	    Sym >= newSym && Sym <= DollarSym) {
# line 1487 "cs.atg"
		PostFixExp();
	} else if (Sym >= PlusPlusSym && Sym <= MinusMinusSym) {
# line 1488 "cs.atg"
		if (Sym == PlusPlusSym) {
# line 1488 "cs.atg"
			Get();
		} else if (Sym == MinusMinusSym) {
# line 1488 "cs.atg"
			Get();
		} else GenError(104);
# line 1488 "cs.atg"
		UnaryExp();
	} else if (Sym == StarSym ||
	           Sym == AndSym ||
	           Sym >= PlusSym && Sym <= MinusSym ||
	           Sym >= BangSym && Sym <= TildeSym) {
# line 1489 "cs.atg"
		UnaryOperator();
# line 1489 "cs.atg"
		CastExp();
	} else GenError(105);
}

# line 1495 "cs.atg"
void cParser::PostFixExp()
{
# line 1495 "cs.atg"
	debug("===>PostFixExp");
# line 1496 "cs.atg"
	Primary();
# line 1497 "cs.atg"
	while (Sym == LbrackSym ||
	       Sym == LparenSym ||
	       Sym >= PlusPlusSym && Sym <= MinusGreaterSym) {
# line 1569 "cs.atg"
		switch (Sym) {
			case LbrackSym:  
# line 1497 "cs.atg"
				Get();
# line 1497 "cs.atg"
				Expression();
# line 1497 "cs.atg"
				Expect(RbrackSym);
# line 1498 "cs.atg"
				
				{
				                              //add command
				                              long op1, op2;
				                              long type1, type2;
				                              TYPEDES dt1, dt2;
				                              //pop
				                              if (!m_pMainFunction->PopDigit(&op2, &type2, &dt2) || !m_pMainFunction->PopDigit(&op1, &type1, &dt1) || type1 <FIRST_ADDRESS_MODE || type1 >LAST_ADDRESS_MODE || type2 <FIRST_ADDRESS_MODE || type2 >LAST_ADDRESS_MODE)
				                              {
				                                      //      REPORT_COMPILE_ERROR("POP UP FAILED");
				                                      GENERR(96);
				                                      return;
				                                      
				                              }
				                              else
				                              {       
				                              /*处理a[b]的流程(要考虑指针， 数组， 多维数组， 作为参数传进来的数组和指针）
				                                      1. 得到b下标代表的单位长度(如果是数组, 通过维数计算, 如果是指针, reflvl减一后计算UnitSize)
				                                      2. b*单位长度= offset 
				                                      3. a + offset -> temp
				                                      4. push temp, 间接寻址
				                                      */
				                                      int offset;
				                                      BOOL bIsArray = TRUE;
				                                      if (dt1.dim >0)//是数组
				                                      {
				                                              bIsArray = TRUE;
				                                              offset= UnitSize(dt1);
				                                              for (int i = 1; i< dt1.dim; i++)
				                                              {
				                                                      offset *= dt1.dimsize[i];
				                                              }
				                                              //不生成新的typedes, 直接修改dt1, 使之维数减一
				                                              if (dt1.dim >1)
				                                                      memcpy(dt1.dimsize, dt1.dimsize+1, sizeof(long)*(dt1.dim-1));                                   
				                                              dt1.dim--;                                                      
				                                      }
				                                      else
				                                      {//不是数组, 是指针
				                                              bIsArray = FALSE;
				                                              if (dt1.refLevel > 0)//是指针且不是指针数组
				                                              {
				                                                      //不生成新的typedes, 直接修改dt1, 使之*号减一
				                                                      dt1.refLevel--;
				                                                      offset = UnitSize(dt1);
				                                              }
				                                              else//既不是指针也不是数组
				                                                      GENERR(101);                                            
				                                      }
				
				                                      //偏移量 = 单位长度* 下标addcommand(mul, DC, 下标, 单位长度)
				                                      ADDCOMMAND2(__mul, (type2<<8)|0x8080, op2, offset)
				                                      //增加临时变量存放中间结果
				                                      long temp = this->AllocTempVar(dtLong);
				                                      if (temp == -1)
				                                      {
				                                              GENERR(98);
				                                      }
				                                      //居卫华2001-08-22
				                                      long lIndirect = (type1>>4)&0x03;
				                                      if (bIsArray == FALSE && lIndirect>0)//如果是指针， 则间接寻址
				                                              ADDCOMMAND2(__add, DR|0x1000, op1, _AX)
				                                      else
				                                              ADDCOMMAND2(__add, DR, op1, _AX)
				                                      //将结果保存到temp
				                                      ADDCOMMAND2(__mov, DR, temp, _AX)
				                                      //入栈, 作为指针用
				                                      m_pMainFunction->PushDigit(temp, AMODE_MEM|0x10|((log2(UnitSize(dt1)))<<6), dt1);
				                              }
				};
				break;
			case LparenSym:  
# line 1570 "cs.atg"
				        
				{
				                      char szName[MAX_IDENTIFIER_LENGTH];
				                      memset(szName, 0, MAX_IDENTIFIER_LENGTH);
				                      Scanner->GetName(&Scanner->CurrSym, szName, MAX_IDENTIFIER_LENGTH-1);//得到名称
				                      long index = m_PubFuncTable->FindFuncByName(szName);
				                      FUNCCALL fn;
				                      fn.name = szName;
				                      if (index < 0) // cannot find function name in public function table, guess is was class method
				                      {
				                              if (m_pCurClassDes){ // if in class scope
				                                      // find in script function table
				                                      CFunction* pScript = m_pCurClassDes->getFuncTable()->GetFunction(szName, &index);
				                                      if (pScript == NULL)
				                                      {       
				                                              GENERR(97);
				                                              Get();
				                                              return;
				                                      }
				                                      else{
				                                              fn.pVF = pScript;
				                                              fn.nType = 0;
				                                              ADDCOMMAND1(__callv, CC, (long)pScript);
				                                              
				                                              // add "this" as first parameter
				                                              printf("add this as parameter for class method\n");
				                                              ADDCOMMAND1(__paramv, 0xc100, 0);
				                                              
				                                              m_pCurClassDes->getFuncTable()->ReleaseFunc();
				                                      }
				                              }
				                              else{
				                                      // TODO support non-class function
				                              }
				                      }
				                      else
				                      {
				                              ADDCOMMAND1(__callpub, CC, (long)(this->m_PubFuncTable->m_FuncTable[index].pfn));
				                              fn.pfn = &m_PubFuncTable->m_FuncTable[index];
				                              fn.nType = 1;                           
				                      }
				
				                                                ;
# line 1613 "cs.atg"
				FunctionCall(&fn);
# line 1614 "cs.atg"
				};
				break;
			case PointSym:  
# line 1616 "cs.atg"
				        printf("==> 1 \n");
				{  // for "break" problem
				      int nStatus = 0;  bool bFun = false;
				
				
# line 1622 "cs.atg"
				Get();
# line 1622 "cs.atg"
				                
				//      long target = NULL;  // the variable presenting a string will be used by _eaobj
				 _typedes(dtTarget, dtStr)
				  dtTarget.refLevel = 1;
				         
				 if (!m_pMainFunction->AddVal(NULL,  dtTarget)){
				         // generror
				         GENERR(113);
				         return;
				 }
				 long address_target;
				 address_target = m_pMainFunction->m_SymbolTable.tableEntry[m_pMainFunction->m_SymbolTable.m_nSymbolCount-1].address;
# line 1659 "cs.atg"
				if (Sym == identifierSym) {
# line 1639 "cs.atg"
					Get();
# line 1640 "cs.atg"
					
					                              char* member = GetCurrSym(); // get identifier
					                              char szName[1024]="";
					                              strcpy(szName, member);
					              
					                              
					                              
					      {
					              // if just identifier, create a string varible for target.
					              int straddress = m_pMainFunction->AddStaticData(strlen(szName)+1, (BYTE*)szName);
					
					          
					      
					           ADDCOMMAND2(__ea, DS, address_target, straddress);
					              
					//           m_pMainFunction->PushDigit(address_target, AMODE_MEM, dtTarget);       
					      
					         
					      };
				} else if (Sym == LbraceSym) {
# line 1659 "cs.atg"
					Get();
# line 1659 "cs.atg"
					Expression();
# line 1660 "cs.atg"
					
					      { // if it is expression, convert the result to string variable by "_evalobj"
					              POPEXP1
					              debug("pop11111");
					      // for simplicity, currently not eval but direct use the string value, so the object must be a string value type,
					      // otherwise, need to call "to_s"
					      //      ADDCOMMAND2(__evalobj, getAddressMode(AMODE_MEM, type1, dtTarget, dt1), address_target, op1);      
					              if (dt1.type != dtGeneral){ // if primitive, convert to object
					                              _typedes(dtTemp, dtGeneral)
					                              ADD_LOCAL_VAR(NULL, dtTemp)
					                              long address_temp = getLastAllocVarAddress();
					                              
					                              // temp <= op1
					                              ADDCOMMAND4(__movobj, getAddressMode2(AMODE_MEM, type1, dtTemp, dt1), address_temp, op1,  dtTemp.type<<4|dtTarget.refLevel, dt1.type<<4|dt1.refLevel); 
					                              
					                              // temp => target
					                              ADDCOMMAND4(__movobj, getAddressMode2(AMODE_MEM, AMODE_MEM, dtTarget, dtTemp), address_target, address_temp,  dtTarget.type<<4|dtTarget.refLevel, dtTemp.type<<4|dt1.refLevel); 
					  
					
					              
					              }else // op1 => target
					                      ADDCOMMAND4(__movobj, getAddressMode2(AMODE_MEM, type1, dtTarget, dt1), address_target, op1,  dtTarget.type<<4|dtTarget.refLevel, dt1.type<<4|dt1.refLevel); 
					  
					      }
					               
					;
# line 1687 "cs.atg"
					Expect(RbraceSym);
				} else GenError(106);
# line 1706 "cs.atg"
				
				      // get target address for a.b
				      // popup a
				      CClassDes *cd = NULL;
				      
				              POPEXP1
				              // must be object
				              if (dt1.type != dtGeneral){
				                      GENERR(129);
				                      return;
				              }
				              if (dt1.type == dtUnknown){ // object not initialized
				                 GENERR(130);
				                 return;
				              }
				                       cd = (CClassDes *)dt1.objID;
				      
				
				      // AX <= a.b
				      ADDCOMMAND2(__eaobj, getAddressMode2(AMODE_MEM, AMODE_MEM, dt1, dtTarget), op1, address_target);
				      long temp = AllocTempVar(dtGeneral);
				      if (temp == -1)
				      {
				                      GENERR(98);
				       }
				      _typedes(DT1, dtGeneral)
				      _typedes(dt_ax, dtGeneral)
				      ADDCOMMAND2(__mov, getAddressMode2(AMODE_MEM, AMODE_REG, DT1, dt_ax), temp, _AX)
				      
				      
				      m_pMainFunction->PushDigit(temp, AMODE_MEM|0x80, DT1);
				/*      // temp <= AX
				      long temp = AllocTempVar(dtGeneral);
				      if (temp == -1)
				      {
				                      GENERR(98);
				       }
				      _typedes(DT1, dtGeneral)
				
				      ADDCOMMAND2(__mov, getAddressMode(AMODE_MEM, AMODE_REG, DT1, DT2), _AX, target);
				      */;
# line 1749 "cs.atg"
				while (Sym == LparenSym) {
# line 1750 "cs.atg"
					
					
					bFun = true;
					FUNCCALL fn;
					//      CFunction* pScript = cd->getMethod(szName);     
					//      fn.name = szName;
					
					//      fn.pVF = pScript;
					fn.nType = 0;
					long op1, type1;
					TYPEDES dt1;
					if (!m_pMainFunction->PopDigit(&op1, &type1, &dt1) || type1 != dtGeneral){
					     GENERR(96);
					     return;
					}
					ADDCOMMAND1(__callv, O0, _AX);
					                     
					// add "this" as first parameter
					printf("add this as parameter for class method\n");
					ADDCOMMAND1(__paramv, O0 , op1);
					                     
					m_pCurClassDes->getFuncTable()->ReleaseFunc();
					
# line 1774 "cs.atg"
					FunctionCall(&fn);
				}
# line 1776 "cs.atg"
				
				/*
				              if (!bFun)
				              {
				int address = m_pMainFunction->AddStaticData(strlen(szName)+1, (BYTE*)szName);
				         //add command
				      long op1, type1;
				      TYPEDES dt1;
				
				         //pop
				          if (!m_pMainFunction->PopDigit(&op1, &type1, &dt1) || type1 != dtGeneral){
				                   GENERR(96);
				                  return;
				          }
				                      else{
				
				                              // get effective address for object member
				                              _typedes(dt2, dtChar)
				                              dt2.refLevel = 1;
				                              ADDCOMMAND2(__eaobj, getAddressMode(AMODE_MEM, AMODE_STATIC, dt1, dt2), op1, address);
				                              
				                              
				                              // move result from AX to Temp variable
				                              long temp = AllocTempVar(dtGeneral);
				                       if (temp == -1)
				                               {
				              GENERR(98);
				                               }
				                              _typedes(DT1, dtGeneral)
				                              _typedes(DT2, dtGeneral)
				                              ADDCOMMAND2(__mov, getAddressMode(AMODE_MEM, AMODE_REG, DT1, DT2), temp, _AX);
				      
				                              m_pMainFunction->PushDigit(temp, AMODE_MEM|0x80, DT1);
				                      }
				              }
				      */
				
				} // for "break" problem ;
				break;
			case MinusGreaterSym:  
# line 1817 "cs.atg"
				{int state = 0;
# line 1817 "cs.atg"
				Get();
# line 1817 "cs.atg"
				while (Sym == LbraceSym) {
# line 1817 "cs.atg"
					Get();
# line 1817 "cs.atg"
					state++;
				}
# line 1817 "cs.atg"
				Expect(identifierSym);
# line 1817 "cs.atg"
				while (Sym == RbraceSym) {
# line 1817 "cs.atg"
					Get();
# line 1817 "cs.atg"
					state++;
				}
# line 1818 "cs.atg"
				
				              if (state == 0)         {                               
				                              //pop
				                              TYPEDES dt;
				                              long type;
				                              long op;
				                              if (!m_pMainFunction->PopDigit(&op, &type, &dt))
				                              {
				                                      GENERR(96);
				                              }
				                              else
				                              {
				                                      if (dt.objID > 0)
				                                      {
				                                              char szName[MAX_IDENTIFIER_LENGTH];
				                                              memset(szName, 0, MAX_IDENTIFIER_LENGTH);
				                                              Scanner->GetName(&Scanner->CurrSym, szName, MAX_IDENTIFIER_LENGTH-1);//得到名称                             
				                                              
				                                              #if 0
				                                              //get offset
				                                              OBJMEMDES* pMember = this->m_ObjTable[dt.objID-1]->GetMemberByName(szName);
				                                              if (pMember == NULL)
				                                              {
				                                                      GENERR(121);                                    
				                                              }
				                                              else
				                                              {       
				                                                      TYPEDES dtTemp;
				                                                      memcpy(&dtTemp, &pMember->dt, sizeof(TYPEDES));
				                                                      
				                                                      long temp = AllocTempVar(dtLong, 1);
				                                                      
				                                                      if (temp == -1)
				                                                      {
				                                                              GENERR(98);
				                                                      }
				                                                      
				                                                      //add(op, offset) = address
				                                                      ADDCOMMAND2(__add, DC, op, pMember->offset)
				                                                      ADDCOMMAND2(__mov, DR, temp, _AX)
				                                                      if ((dtTemp.dim ==0 && dtTemp.objID == 0 )
				                                                              ||(dtTemp.objID > 0 && dtTemp.refLevel > 0))
				                                                              {//如果不是数组和obj
				                                                                      
				                                                                      //取改member的opsize
				                                                                      int opsize;
				                                                                      if (dtTemp.refLevel > 0) //如果是指针类型
				                                                                              opsize = log2(OPSIZE_PTR);
				                                                                      else
				                                                                              opsize = log2(typesize(dtTemp.type, dtTemp.objID));
				                                                                      opsize &= 0x3;
				                                                                      m_pMainFunction->PushDigit(temp, AMODE_MEM|(opsize << 6)|0x10, dtTemp);
				                                                                      
				                                                              }
				                                                              else
				                                                              {
				                                                                      
				                                                                      //如果是数组或obj, 生成临时变量存放数组地址
				                                                                      if (dtTemp.dim != 0)
				                                                                      {                                                                       
				                                                                              /*居卫华2001-08-22修改
				                                                                              dtTemp.refLevel++;
				                                                                              dtTemp.dim--;
				                                                                              */
				                                                                              m_pMainFunction->PushDigit(temp, AMODE_MEM|(log2(OPSIZE_PTR)<<6), dtTemp);
				                                                                      }
				                                                                      else
				                                                                      {
				                                                                              dtTemp.refLevel++;
				                                                                              m_pMainFunction->PushDigit(temp, AMODE_MEM|(log2(OPSIZE_PTR)<<6), dtTemp);
				                                                                      }
				                                                              }
				                                                              
				                                              }
				                                              #endif
				                                      }
				                              }
				                      }
				                      } // int state
				                      ;
				break;
			case PlusPlusSym:  
# line 1905 "cs.atg"
				Get();
# line 1907 "cs.atg"
				
				              {
				                              long op1;
				                              long type1;
				                              TYPEDES dt1;
				                              //pop出被加数
				                              if (!m_pMainFunction->PopDigit(&op1, &type1, &dt1) || type1 <FIRST_ADDRESS_MODE || type1 >LAST_ADDRESS_MODE) 
				                              {
				                                      //      REPORT_COMPILE_ERROR("POP UP FAILED");
				                                                              GENERR(96);
				                      return;
				
				                              }
				                              else
				                              {
				                                      if (dt1.type == dtUnknown){
				                                              GENERR(130);
				                                              return;
				                                      }
				                                      if (dt1.type == dtFloat)
				                                      {
				                                              GENERR(112);
				                                      }
				                                      else
				                                      {
				                                              //get address mode
				                                              int address_mode = (type1<<8);
				                                              address_mode |= (log2(UnitSize(dt1))<<14)|(log2(UnitSize(dt1))<<6);     
				                                              if (dt1.dim >0)
				                                              {//如果是数组变量
				                                                      //得到增量
				                                                      int size = UnitSize(dt1);
				                                                      for (int i=1; i<dt1.dim;i++)
				                                                      {
				                                                              size *= dt1.dimsize[i];
				                                                      }
				                                                      //加法
				                                                      ADDCOMMAND2(__add, (type1<<8)|0x80, op1, size)
				                                              }
				                                              else
				                                              {
				                                                      //add commmand to command table
				                                                      ADDCOMMAND2(__add, address_mode, op1, 1)        
				                                              }       
				                                              ADDCOMMAND2(__mov, address_mode|0x02, op1, _AX); 
				                                              //将AX中的结果存入临时变量
				                                              m_pMainFunction->PushDigit(op1, type1, dt1);
				                                      }
				                              }
				                      }
				              ;
				break;
			case MinusMinusSym:  
# line 1959 "cs.atg"
				Get();
# line 1961 "cs.atg"
				
				                      {
				                              long op1;
				                              long type1;
				                              TYPEDES dt1;
				                              //pop出被加数
				                              if (!m_pMainFunction->PopDigit(&op1, &type1, &dt1) || type1 <FIRST_ADDRESS_MODE || type1 >LAST_ADDRESS_MODE) 
				                              {
				                                      //      REPORT_COMPILE_ERROR("POP UP FAILED");
				                                                              GENERR(96);
				                      return;
				
				                              }
				                              else
				                              {
				                                      if (dt1.type == dtUnknown){
				                                              GENERR(130);
				                                              return;
				                                      }
				                                      if (dt1.type == dtFloat)
				                                      {
				                                              GENERR(112);
				                                      }
				                                      else
				                                      {
				                                              //get address mode
				                                              int address_mode = (type1<<8);
				                                              address_mode |= (log2(UnitSize(dt1))<<14)|(log2(UnitSize(dt1))<<6);     
				                                              if (dt1.dim >0)
				                                              {//如果是数组变量
				                                                      //得到增量
				                                                      int size = UnitSize(dt1);
				                                                      for (int i=1; i<dt1.dim;i++)
				                                                      {
				                                                              size *= dt1.dimsize[i];
				                                                      }
				                                                      //加法
				                                                      ADDCOMMAND2(__sub, (type1<<8)|0x80, op1, size)
				                                              }
				                                              else
				                                              {
				                                                      //add commmand to command table
				                                                      ADDCOMMAND2(__sub, address_mode, op1, 1)        
				                                              }       
				                                              ADDCOMMAND2(__mov, address_mode|0x02, op1, _AX); 
				                                              //将AX中的结果存入临时变量
				                                              m_pMainFunction->PushDigit(op1, type1, dt1);
				                                      }
				                              }
				                      };
				break;
			default :GenError(107); break;
		}
	}
}

# line 2630 "cs.atg"
void cParser::UnaryOperator()
{
# line 2630 "cs.atg"
	switch (Sym) {
		case PlusSym:  
# line 2630 "cs.atg"
			Get();
			break;
		case MinusSym:  
# line 2630 "cs.atg"
			Get();
			break;
		case StarSym:  
# line 2630 "cs.atg"
			Get();
			break;
		case BangSym:  
# line 2630 "cs.atg"
			Get();
			break;
		case AndSym:  
# line 2630 "cs.atg"
			Get();
			break;
		case TildeSym:  
# line 2630 "cs.atg"
			Get();
			break;
		default :GenError(108); break;
	}
}

# line 2207 "cs.atg"
void cParser::Primary()
{
# line 2208 "cs.atg"
	
	      char szName[MAX_IDENTIFIER_LENGTH];
	      memset(szName, 0, MAX_IDENTIFIER_LENGTH);
# line 2316 "cs.atg"
	switch (Sym) {
		case identifierSym:  
# line 2212 "cs.atg"
			Get();
# line 2212 "cs.atg"
			
			
			  {
			Scanner->GetName(&Scanner->CurrSym, szName, MAX_IDENTIFIER_LENGTH-1);//得到名称
			  
			          
			          int address = -1;
			/*              
			          bool bThis = false;     
			          if (strcmp(szName, "this")==0){
			          // check whether this is a class method
			                  if (m_pCurClassDes){
			                          bThis = true;
			                          address = 0;
			                  }else{
			                          GENERR(127);
			                  }
			          }else
			              address = GetSymAddress(szName); // return -1 if not found
			  */
			          address = GetSymAddress(szName); // try to get symbol from main function and its ancestor
			          printf("identiefier=%s, address=%x\n", szName, address);        
			
			           // address < 0 => function, address >= 0 => variable
			                    if (address >= 0 )// is a variable of current main function, push it into expression stack
			                    {
			                            TYPEDES dt;
			                            SYMBOLTABLEELE *pElement = m_pMainFunction->m_SymbolTable.GetSym(szName);
			                            if (pElement == NULL)
			                            {
			                                                            printf("===>generror 115, symbol name=%s", szName);
			                                    GENERR(115); // not found it symbol table, check it in runtime
			                            }
			                            else
			                            {
			                                    memcpy(&dt ,&(pElement->type), sizeof(TYPEDES));
			                                    /*if (pdt == NULL)
			                                    {
			                                    GENERR(111);
			                                    }
			                                    else*/
			                            
			                                    if ((dt.dim ==0 && dt.type !=dtGeneral ) // if not array and not object
			                                            || (dt.type ==dtGeneral  && dt.refLevel > 0)) // if is pointer to object 
			                                    {//如果不是数组和obj
			                                            int opsize;
			                                            if (dt.refLevel > 0) 
			                                                    opsize = log2((int)OPSIZE_PTR);
			                                            else
			                                                    opsize = log2((int)typesize(dt.type, dt.objID));
			                                            opsize &= 0x3;
			                  debug("primary: push primitive");
			                                            m_pMainFunction->PushDigit(address, AMODE_MEM|(opsize << 6), dt);
			                                    }
			                                    else
			                                    {//如果是数组或obj, 生成临时变量存放数组地址
			                                            if (dt.dim != 0)
			                                            {
			                                                    long temp = AllocTempVar(dtLong, 1);
			                                                    if (temp == -1)
			                                                    {
			                                                            GENERR(98);
			                                                    }
			                                                    
			                                                    ADDCOMMAND2(__ea, DD, temp, address)
			                                                    /*居卫华2001－8－22修改
			                                                    dt.refLevel++;
			                                                    dt.dim--;
			                                                    */
			                  debug("primary: push array");
			                                                    m_pMainFunction->PushDigit(temp, AMODE_MEM|(log2( (int)(OPSIZE_PTR) )<<6), dt);
			                                            }
			                                            else // if it is object
			                                            {
			                                                                                   // int opsize;
			                                                                                   // opsize = log2((int)OPSIZE_PTR);
			                                               // opsize &= 0x3;
			                                                                                  //  m_pMainFunction->PushDigit(address, AMODE_MEM|(opsize << 6), dt);
			                                                                                  debug("primary: push obj");
			                                                                                  m_pMainFunction->PushDigit(address, getAddressModeForExpStack(AMODE_MEM, dt), dt);
			                                            }
			                                    }
			                                    
			                            }
			                    }
			          else // address < 0, not found in symbol table
			          {
			                  //GENERR(126);
			                  if (this->m_PubFuncTable->FindFuncByName(szName) < 0) // not found in pub function table
			                  {
			                          // find it in class methods
			                          long index = 0;
			                          if (m_pCurClassDes->getFuncTable()->GetFunction(szName, &index) == NULL){ // not found in class function table
			                                  // cannot create an object variable for it, because it maybe a function call
			                                  GENERR(104);
			                          } 
			
			                          else
			                                  m_pCurClassDes->getFuncTable()->ReleaseFunc();
			                  }
			                  //      return;
			          }
			};
			break;
		case newSym:  
# line 2316 "cs.atg"
			Get();
# line 2316 "cs.atg"
			Creator();
			break;
		case DollarSym:  
# line 2318 "cs.atg"
			Get();
# line 2319 "cs.atg"
			{
			      TYPEDES dt;
			      SYMBOLTABLEELE *pElement = m_pMainFunction->m_SymbolTable.GetSym("this");
			      if (pElement == NULL){
			         ERR1p("Cannot find variable %s", "this");
			         GENERR(115); // not found it symbol table, check it in runtime
			      return;
			      }
			      memcpy(&dt ,&(pElement->type), sizeof(TYPEDES));
			      long address = GetSymAddress("this");
			      m_pMainFunction->PushDigit(address, getAddressModeForExpStack(AMODE_MEM, dt), dt);
			      printf("===>push $\n");
			};
			break;
		case stringD1Sym:  
# line 2353 "cs.atg"
			Get();
# line 2354 "cs.atg"
			
			             {
			                            printf("===>string1\n");
			                                        char* pCh;
			                                        pCh = new char[Scanner->CurrSym.Len+1];
			                                        if (pCh == NULL)
			                                        {
			                                                GENERR(106);
			                                                Get();
			                                                break;
			                                        }
			                                        memset(pCh, 0, Scanner->CurrSym.Len+1);
			                                                            Scanner->GetName(&Scanner->CurrSym, pCh, Scanner->CurrSym.Len);//得到名称
			                                                                    printf("primary=%s\n", pCh);
			                                           char* string = NULL;
			                                        string = AnalyzeConstString(pCh);
			                                     if (string == NULL)
			                                        {
			                                                if (pCh)
			                                                        delete pCh;
			                                                GENERR(100);                          
			                                                Get();
			                                                break;
			                                        }
			                    
			                                        int straddress = this->m_pMainFunction->m_nSSUsedSize;
			                                        if (m_pMainFunction->AddStaticData(strlen(string)+1, (BYTE*)string)>=0)
			                                        {       
			                                                _typedes(dt, dtStr)
			                                                dt.refLevel = 1;
			                                                if (m_pMainFunction->AddVal(NULL,  dt))
			                                                {
			                                                        long temp;
			                                                        temp = m_pMainFunction->m_SymbolTable.tableEntry[m_pMainFunction->m_SymbolTable.m_nSymbolCount-1].address;
			                                                        ADDCOMMAND2(__ea, DS, temp, straddress);
			                                                        m_pMainFunction->PushDigit(temp, AMODE_MEM, dt);                         
			                                                }
			                                        }
			                                        else
			                                        {
			                                                this->GENERR(98);
			                                        }
			                                            
			                                                            if (string)
			                                                delete string;
			                                                            if (pCh)
			                                                delete pCh;         
			                                };
			break;
		case charD1Sym:  
# line 2404 "cs.atg"
			Get();
# line 2405 "cs.atg"
			
			            {
			                    Scanner->GetName(&Scanner->NextSym, szName, MAX_IDENTIFIER_LENGTH-1);//得到名称
			                    _typedes(dt,dtChar);
			                    m_pMainFunction->PushDigit(szName[1], AMODE_DIRECT, dt);
			            }
			;
			break;
		case numberSym:  
# line 2413 "cs.atg"
			Get();
# line 2414 "cs.atg"
			
			
			debug("push number");
			             if (strchr(szName, '.'))        // float
			             {
			                     
			                     float number = (float)atof(GetCurrSym());
			                     _typedes(dt, dtFloat);                  
			                     m_pMainFunction->PushDigit(*(long*)&number, AMODE_DIRECT|OPSIZE_4B, dt);
			             }
			             else    // int
			             {
			                     
			                     int number = atoi(GetCurrSym());
			                     _typedes(dt, dtLong);                   
			                     // Address mode: direct, Operation=4Byte =>0x80
			                     m_pMainFunction->PushDigit(number, AMODE_DIRECT|OPSIZE_4B, dt);
			             }
			;
			break;
		case LparenSym:  
# line 2434 "cs.atg"
			Get();
# line 2434 "cs.atg"
			Expression();
# line 2434 "cs.atg"
			Expect(RparenSym);
			break;
		case LbraceSym:  
# line 2435 "cs.atg"
			SetDef();
			break;
		default :GenError(109); break;
	}
}

# line 2438 "cs.atg"
void cParser::FunctionCall(FUNCCALL* pFuncEntry)
{
# line 2438 "cs.atg"
	Expect(LparenSym);
# line 2439 "cs.atg"
	
	     debug("=====>FunctionCall");
	     // if this is object instance method, attach "this" first.
	     ;
# line 2446 "cs.atg"
	if (Sym >= identifierSym && Sym <= numberSym ||
	    Sym >= stringD1Sym && Sym <= charD1Sym ||
	    Sym == LbraceSym ||
	    Sym == LparenSym ||
	    Sym == StarSym ||
	    Sym == AndSym ||
	    Sym >= PlusSym && Sym <= MinusSym ||
	    Sym >= PlusPlusSym && Sym <= MinusMinusSym ||
	    Sym >= newSym && Sym <= DollarSym ||
	    Sym >= BangSym && Sym <= TildeSym) {
# line 2446 "cs.atg"
		ActualParameters(pFuncEntry);
	}
# line 2446 "cs.atg"
	Expect(RparenSym);
# line 2447 "cs.atg"
	
	    debug("======>functioncall2 ");
	//long lParamNum = 0;
	    if (pFuncEntry->nType) // public function
	    {
	
	debug("pub function");
	            //addcommand
	            ADDCOMMAND0(__endcallpub);
	            //save return value
	            _typedes(dt, dtLong)
	            if (m_pMainFunction->AddVal(NULL, dt))
	            {                       
	                    long temp;
	                    temp = m_pMainFunction->m_SymbolTable.tableEntry[m_pMainFunction->m_SymbolTable.m_nSymbolCount-1].address;
	                    ADDCOMMAND2(__mov, DR, temp , _AX);
	                    m_pMainFunction->PushDigit(temp, AMODE_MEM|0x80, dt);
	            }
	            else
	            {
	                    GENERR(98);
	            }
	                            
	    }
	    else // virtual function
	    {
	            debug("virtual function");
	            // check param number
	            //if (lParamNum != pFuncEntry->pVF->m_iParamNum)
	            //{
	            //      GENERR(123);
	            //}
	
	            //addcommand
	            ADDCOMMAND0(__endcallv);
	
	            //save return value
	            _typedes(dt, dtLong)
	            if (m_pMainFunction->AddVal(NULL, dt))
	            {
	                    long temp;
	                    temp = m_pMainFunction->m_SymbolTable.tableEntry[m_pMainFunction->m_SymbolTable.m_nSymbolCount-1].address;
	                    ADDCOMMAND2(__mov, DR, temp , _AX);
	                    m_pMainFunction->PushDigit(temp, AMODE_MEM|0x80, dt);
	            }
	            else
	            {
	                    this->GENERR(98);
	            }
	    }
	            debug("======>functioncall3 ");
}

# line 2015 "cs.atg"
void cParser::SetDef()
{
# line 2015 "cs.atg"
	Expect(LbraceSym);
# line 2016 "cs.atg"
	
	      _typedes(dtTemp, dtGeneral)
	      long temp = AllocTempVar(dtGeneral, 0);
	  if (temp == -1)
	  {
	          GENERR(98);
	  }
	      ADDCOMMAND1(__newobj,RS, -1); // create object and set to AX
	      _typedes(dtAx, dtGeneral)     // temp <= Ax
	      ADDCOMMAND4(__movobj, getAddressMode2(AMODE_MEM, AMODE_REG, dtTemp, dtAx), temp, _AX,  dtGeneral<<4, dtGeneral<<4); 
	              
# line 2028 "cs.atg"
	while (Sym >= identifierSym && Sym <= numberSym ||
	       Sym >= stringD1Sym && Sym <= charD1Sym ||
	       Sym == LbraceSym ||
	       Sym == LparenSym ||
	       Sym == StarSym ||
	       Sym == AndSym ||
	       Sym >= PlusSym && Sym <= MinusSym ||
	       Sym >= PlusPlusSym && Sym <= MinusMinusSym ||
	       Sym >= newSym && Sym <= DollarSym ||
	       Sym >= BangSym && Sym <= TildeSym) {
# line 2028 "cs.atg"
		SetItems(temp);
	}
# line 2032 "cs.atg"
	
	     // push the newly created hash
	     _typedes(dt1, dtGeneral);
	     m_pMainFunction->PushDigit(temp, AMODE_MEM, dt1);
# line 2038 "cs.atg"
	Expect(RbraceSym);
}

# line 2039 "cs.atg"
void cParser::SetItems(long temp)
{
# line 2039 "cs.atg"
	HashItem(temp);
# line 2039 "cs.atg"
	while (Sym == CommaSym) {
# line 2039 "cs.atg"
		Get();
# line 2039 "cs.atg"
		HashItem(temp);
	}
}

# line 2042 "cs.atg"
void cParser::HashItem(long temp)
{
# line 2042 "cs.atg"
	int state = 0;
# line 2055 "cs.atg"
	if (Sym == identifierSym) {
# line 2044 "cs.atg"
		Get();
# line 2045 "cs.atg"
		
		              GET_NAME
		              int address = m_pMainFunction->AddStaticData(strlen(szName)+1, (BYTE*)szName);
		              _typedes(dtName, dtChar)
		              dtName.refLevel = 1;
		              m_pMainFunction->PushDigit(address, AMODE_STATIC, dtName);
		              /*** static data cannot be used directly,normally should move to temp variable first ***/
		;
	} else if (Sym == numberSym ||
	           Sym >= stringD1Sym && Sym <= charD1Sym ||
	           Sym == LbraceSym ||
	           Sym == LparenSym ||
	           Sym == StarSym ||
	           Sym == AndSym ||
	           Sym >= PlusSym && Sym <= MinusSym ||
	           Sym >= PlusPlusSym && Sym <= MinusMinusSym ||
	           Sym >= newSym && Sym <= DollarSym ||
	           Sym >= BangSym && Sym <= TildeSym) {
# line 2055 "cs.atg"
		while (Sym == LbraceSym) {
# line 2055 "cs.atg"
			Get();
# line 2055 "cs.atg"
			state++;
		}
# line 2055 "cs.atg"
		        
# line 2055 "cs.atg"
		Expression();
# line 2055 "cs.atg"
		        
# line 2055 "cs.atg"
		while (Sym == RbraceSym) {
# line 2055 "cs.atg"
			Get();
		}
	} else GenError(110);
# line 2060 "cs.atg"
	
	              if (state == 0)         {       // identifier           
	                      debug("identifier");    
	                      //pop
	                      POPEXP1
	
	                      //      long target = NULL;  // the variable presenting a string will be used by as hash name
	                      _typedes(dtTarget, dtStr)
	                       dtTarget.refLevel = 1;
	                      ADD_LOCAL_VAR(NULL, dtTarget)
	                      long address_target = getLastAllocVarAddress();
	                      debug("type1=%x", type1);
	                      ADDCOMMAND2(__ea, DS, address_target, op1);
	              //      ADDCOMMAND4(__movobj, getAddressMode2(AMODE_MEM, type1, dtTarget, dt1), address_target, op1,  dtTarget.type<<4|dtTarget.refLevel, dt1.type<<4|dt1.refLevel); 
	                      m_pMainFunction->PushDigit(address_target, AMODE_MEM, dtTarget);        
	              }
	              else{ // Expression
	                      debug("expression");
	                      //pop
	                      POPEXP1
	
	                      _typedes(dtTarget, dtStr)
	                       dtTarget.refLevel = 1;
	                      ADD_LOCAL_VAR(NULL, dtTarget)
	                      long address_target = getLastAllocVarAddress();// the variable presenting a string will be used by as hash name
	                      debug("type1=%x", type1);
	      //              ADDCOMMAND2(__ea, DS, address_target, op1);
	                      ADDCOMMAND4(__movobj, getAddressMode2(AMODE_MEM, type1, dtTarget, dt1), address_target, op1,  dtTarget.type<<4|dtTarget.refLevel, dt1.type<<4|dt1.refLevel); 
	                      m_pMainFunction->PushDigit(address_target, AMODE_MEM, dtTarget);        
	              }
	              debug("hash name");
	
	              
# line 2093 "cs.atg"
	Expect(ColonSym);
# line 2093 "cs.atg"
	Expression();
# line 2094 "cs.atg"
	
	      
	      // op2 <= value, op1<=member
	      POPEXP2
	              
	      // get address temp.xxx => _AX
	      _typedes(dtTemp, dtGeneral)
	      ADDCOMMAND2(__eaobj, getAddressMode2(AMODE_MEM, AMODE_MEM, dtTemp, dt1), temp, op1);
	      
	      // Temp1 < ax
	      _typedes(DT1, dtGeneral)
	      ADD_LOCAL_VAR(NULL, DT1)
	      long address_temp1 = getLastAllocVarAddress();
	      
	      _typedes(dt_ax, dtGeneral)
	      ADDCOMMAND2(__mov, getAddressMode2(AMODE_MEM, AMODE_REG, DT1, dt_ax), address_temp1, _AX)
	      
	      printf("op2 type=%d, reflevel=%d\n", dt2.type, dt2.refLevel);
	      
	      // set temp.xxx = op2
	      ADDCOMMAND4(__movobj, getAddressMode2(AMODE_MEM, type2 , DT1, dt2), address_temp1, op2,  dtGeneral<<4, dt2.type<<4|dt2.refLevel); 
	
	
	
	
}

# line 2123 "cs.atg"
void cParser::Creator()
{
# line 2124 "cs.atg"
	char szName[_MAX_PATH] = "";
# line 2125 "cs.atg"
	ClassFullName(szName);
# line 2126 "cs.atg"
	        
	   CClassDes* cd = this->m_classTable->getClass(szName);
	   if (cd == NULL){
	           std::string s = JUJU::getFilePath(c->getCurSrcFile())+szName;
	           strcpy(szName, s.c_str());
	           cd = this->m_classTable->getClass(szName);
	           if (cd == NULL){
	                           strcat(szName, SCRIPT_EXT);
	                           CCompiler cc;      
	                           if (m_conf)     
	                                   cc.setConf(*m_conf);
	               cc.Compile(szName);
	       }
	           // TODO generete correct error
	           //GENERR(100);
	           //return;
	   }
	   int address = m_pMainFunction->AddStaticData(strlen(szName)+1, (BYTE*)szName);
	   ADDCOMMAND1(__newobj,DS, address); // create object to set to AX
	   
	// mov result from ax to temp and push temp variable
	   TYPEDES dt1;
	   memset(&dt1, 0, sizeof(TYPEDES));
	   dt1.type = dtGeneral;
	   dt1.objID = (long)cd;
	// 将AX中的结果存入临时变量
	   long temp = NULL;
	   if (m_pMainFunction->AddVal(NULL,  dt1))
	   {                       
	           
	                   long opsize = log2(UnitSize(dt1))<<6;
	                   temp = m_pMainFunction->m_SymbolTable.tableEntry[m_pMainFunction->m_SymbolTable.m_nSymbolCount-1].address;
	                   ADDCOMMAND2(__mov, DR|((opsize<<8)|opsize), temp , _AX);
	                   m_pMainFunction->PushDigit(temp, AMODE_MEM, dt1);
	   }
	   else
	   {
	                   REPORT_COMPILE_ERROR("add symbol failed");
	   }
	;
# line 2167 "cs.atg"
	
	      FUNCCALL fn;
	      CFunction* pScript = cd->getMethod("create");   
	      fn.name = "::create";
	  
	      fn.pVF = pScript;
	      fn.nType = 0;
	      ADDCOMMAND1(__callv, CC, (long)pScript);
	                              
	      // add "this" as first parameter
	      printf("add this as parameter for class method\n");
	      ADDCOMMAND1(__paramv, O0 , temp);
	                              
	      m_pCurClassDes->getFuncTable()->ReleaseFunc();
# line 2182 "cs.atg"
	while (Sym == LparenSym) {
# line 2182 "cs.atg"
		FunctionCall(&fn);
	}
# line 2183 "cs.atg"
	
	      
	      
	      // pop function return value, because the constructor return value should be discarded
	      {
	              long op1;
	              long type;
	              TYPEDES dt1;
	              if (!m_pMainFunction->PopDigit(&op1, &type, &dt1)|| type <FIRST_ADDRESS_MODE || type >LAST_ADDRESS_MODE )
	              {
	              //      REPORT_COMPILE_ERROR("POP UP FAILED");
	                      this->GENERR(96);
	                      return;
	              }
	      };
}

# line 2500 "cs.atg"
void cParser::ActualParameters(FUNCCALL* pFuncEntry)
{
# line 2501 "cs.atg"
	
	//      lParamNum = 0;
	    if (pFuncEntry == NULL)
	            return;
	
	    char cParamNum = 0;     
	
# line 2508 "cs.atg"
	Expression();
# line 2509 "cs.atg"
	
	    //pop
	    long op1;
	    long type;
	    TYPEDES dt1;
	    if (!m_pMainFunction->PopDigit(&op1, &type, &dt1)|| type <FIRST_ADDRESS_MODE || type >LAST_ADDRESS_MODE )
	    {
	    //      REPORT_COMPILE_ERROR("POP UP FAILED");
	            this->GENERR(96);
	            return;
	    }
	    // address mode of dest op is in hight byte
	    int address_mode = (type<<8)&0xff00;
	    // set op number size
	    address_mode |= (log2(UnitSize(dt1))<<14);
	
	    if (pFuncEntry->nType)  // native function
	            ADDCOMMAND1(__parampub, address_mode, op1)                      
	    else{
	            // validate parameter type
	            //CFunction* fun = pFuncEntry->pVF;
	                                    long temp = AllocTempVar(dtGeneral);
	                                    if (temp == -1)
	                                                                     {
	                                                    GENERR(98);
	                                                                     }
	            _typedes(DTT, dtGeneral)
	            ADDCOMMAND4(__movobj, getAddressMode2(AMODE_MEM,type, DTT, dt1), temp, op1, DTT.type<<4|DTT.refLevel, dt1.type<<4|dt1.refLevel);
	            ADDCOMMAND1(__paramv, (AMODE_MEM|0xc0)<<8, temp)
	    }
	    cParamNum++; 
# line 2541 "cs.atg"
	while (Sym == CommaSym) {
# line 2541 "cs.atg"
		Get();
# line 2541 "cs.atg"
		Expression();
# line 2543 "cs.atg"
		
		                    // modified on 20030331 by weihua ju
		//                      if (cParamNum > pFuncEntry->params.size()-1)
		//                      {
		//                              GENERR(106);
		//                      }
		
		                    //pop
		                    long op1;
		                    long type;
		                    TYPEDES dt1;
		                    if (!m_pMainFunction->PopDigit(&op1, &type, &dt1)|| type <FIRST_ADDRESS_MODE || type >LAST_ADDRESS_MODE)
		                    {
		                            //      REPORT_COMPILE_ERROR("POP UP FAILED");
		                            GENERR(96);
		                            return;
		                    }
		                    else
		                    {
		                            //get address mode
		                            int address_mode = (type<<8)&0xff00;
		                            address_mode |= (log2(UnitSize(dt1))<<14);
		                            
		                            /*              保留
		                            if (dt1.dim > 0)
		                            {
		                            _typedes(dt, dtInt)
		                            long temp;
		                            //如果是数组, 把它的地址存入临时变量, 传入临时变量
		                            if (m_pMainFunction->AddVal(NULL, dt))
		                            {                       
		                            temp = m_pMainFunction->m_SymbolTable.tableEntry[m_pMainFunction->m_SymbolTable.m_nSymbolCount-1].address;
		                            ADDCOMMAND2(__ea, DD, temp, op1);
		                            }
		                            long size = sizeof(long*);
		                            size = log2(size);
		                            size = size << 14;
		
		                            ADDCOMMAND1(__parampub, size|0x100, temp)       
		                            }
		                            else    
		                            */      
		                            if (pFuncEntry->nType){         // native function
		                                    
		                                    /*// if its object, create temp variable and pass into function call            
		                                    if (m_pMainFunction->AddVal(NULL, dt))
		                                    {                       
		                                        long temp = m_pMainFunction->m_SymbolTable.tableEntry[m_pMainFunction->m_SymbolTable.m_nSymbolCount-1].address;
		                                            ADDCOMMAND2(__movobj, DD, temp, op1);
		                                    }
		                                    else{
		                                            REPORT_COMPILE_ERROR("add symbol failed");
		                                            return FALSE;
		                                    }*/
		                                    ADDCOMMAND1(__parampub, address_mode, op1)                      
		                            }       
		                            else{
		                                    // if its object, create temp variable and pass into function call              
		                                    long temp = AllocTempVar(dtGeneral);
		                                    if (temp == -1)
		                                                                     {
		                                                    GENERR(98);
		                                                                     }
		                    
		                                    _typedes(DTT, dtGeneral)
		                                    ADDCOMMAND4(__movobj, getAddressMode2(AMODE_MEM,type, DTT, dt1), temp, op1, DTT.type<<4|DTT.refLevel, dt1.type<<4|dt1.refLevel);
		                                    ADDCOMMAND1(__paramv, (AMODE_MEM|0xc0)<<8, temp)
		                            }       
		                            cParamNum++; 
		                    }               
		;
	}
# line 2616 "cs.atg"
	
	            // code added on 20030331 weihua ju
	            if ((pFuncEntry->nType!=0) && cParamNum != pFuncEntry->pfn->cParamNum)
	            {
	
	                    GENERR(106);
	            }
	    //lParamNum = cParamNum;
}



void cParser::Parse()
{ Scanner->Reset(); Get();
  C();
}

//////////////////////////////////
// add by jackie juju

// all these function maybe should be move to single class
BOOL cParser::AllocVar(PTYPEDES type, char *szName)
{
printf("allocate var for %s\n", szName);
	/*int size_t = 0;
	//get size 
	if (nType < 0)
	{
		size_t = sizeof(long);
	}
	else
	{
		switch(nType)
		{
		case dtShort:
			size_t = 1;
			break;

		case dtInt:
			size_t = 2;
			break;
		case dtLong:
			size_t = 4;
			break;
		case dtChar:
			size_t = 1;
			break;
		case dtString:
			size_t = 4;
			break;
		case dtStrArray:
			size_t = 4;
			break;
		default:
			REPORT_COMPILE_ERROR("undefined type");
			return -1;
		}
	}
*/

	if (m_pMainFunction) // in function definition
		return m_pMainFunction->AddVal(szName, *type);
	else
		return this->m_pCurClassDes->AddMember(szName, *type);

}

long cParser::getLastAllocVarAddress(){
	return m_pMainFunction->m_SymbolTable.tableEntry[m_pMainFunction->m_SymbolTable.m_nSymbolCount-1].address;
}
BOOL cParser::PopOp(int *op)
{
	if (op == NULL)
		return FALSE;
	*op = 0;
	if (this->m_pExpOpPt->pPrev == NULL)
		return FALSE;
	*op  = m_pExpOpPt->opcode;
	EXPRESSIONOP *pTemp = m_pExpOpPt;
	m_pExpOpPt = m_pExpOpPt->pPrev;
	delete pTemp;
	return TRUE;
}


/*
   函数名称     : cParser::PushExpOp
   函数功能	    : 一元运算符入栈
   变量说明     : 
   int op: 运算符
   返回值       : 
   编写人       : 居卫华
   完成日期     : 2001 - 6 - 6
*/
void cParser::PushExpOp(int op)
{
	EXPRESSIONOP *pNew = new EXPRESSIONOP;	
	if (pNew == NULL)
	{
		REPORT_MEM_ERROR("memory allocation error");
		return;
	}

	pNew->opcode = op;
	pNew->pPrev = m_pExpOpPt;
	m_pExpOpPt = pNew;
}
/*

void cParser::PushExpOp2(int op)
{
	EXPRESSIONOP *pNew = new EXPRESSIONOP;	
	pNew->opcode = op;
	pNew->pPrev = m_pExpOpPt2;
	m_pExpOpPt2 = pNew;
}

void cParser::PushExpDigit2(long digit, int type)
{
	EXPRESSIONDIGIT *pNew = new EXPRESSIONDIGIT;	
	pNew->digit = digit;
	pNew->type = type;
	pNew->pPrev = this->m_pExpDigitPt2;

	m_pExpDigitPt2 = pNew;
}

BOOL cParser::PopOp2(int *op)
{
	if (this->m_pExpOpPt2->pPrev == NULL)
		return FALSE;
	*op  = m_pExpOpPt2->opcode;
	EXPRESSIONOP *pTemp = m_pExpOpPt2;
	m_pExpOpPt2 = m_pExpOpPt2->pPrev;
	delete pTemp;
	return TRUE;
}

BOOL cParser::PopDigit2(long *digit, int *type)
{
	if (this->m_pExpDigitPt2->pPrev == NULL)
		return FALSE;
	*digit = m_pExpDigitPt2->digit;
	*type = m_pExpDigitPt2->type;
	EXPRESSIONDIGIT *pTemp = m_pExpDigitPt2;
	m_pExpDigitPt2 = m_pExpDigitPt2->pPrev;
	delete pTemp;
	return TRUE;
}

*/


void cParser::ClearOpStack()
{
	while (this->m_pExpOpPt->pPrev != NULL)
	{
		EXPRESSIONOP *pTemp = m_pExpOpPt;
		this->m_pExpOpPt = this->m_pExpOpPt->pPrev;
		delete pTemp;
	}
	m_pExpOpPt = &m_ExpOp;
}

int cParser::GetSymAddress(char *szName)
{
	int ret = -1;
	ret = this->m_pMainFunction->GetSymbolAddress(szName);
	CFunction* p = m_pMainFunction;
	while (p != NULL){
		ret = p->GetSymbolAddress(szName);
		if (ret >= 0)
			return ret;
		p = p->getParent();
	}
	return ret;
}


void cParser::AddNewLoop()
{
	CLoopTree *pNew = new CLoopTree(m_pMainFunction);

	m_curloop->AddNew(*pNew);

	this->m_curloop = pNew;
}

void cParser::ExitCurLoop()
{
	this->m_curloop = m_curloop->m_parent;
	m_curloop->RemoveChild();

}

void cParser::SetPubFuncTable(CPubFuncTable *pTable)
{
	this->m_PubFuncTable = pTable;
}



BOOL cParser::AllocArrayVar(PTYPEDES type, char *szName, int size)
{
	if (!m_pMainFunction->AddVal(szName, *type))
		return FALSE;
	//if (!m_pMainFunction->AddVal(NULL, type->size_t*size, type->type)||!m_pMainFunction->AddVal(szName, typesize(dtInt), dtInt))
	//	return FALSE;
	
	return TRUE;
}

char* cParser::AnalyzeConstString(char *string)
{
	int size = 0;
	int len = strlen(string);
	if (len == 0)
		return NULL;

	char *p = string;
	char *newstring = new char[len+1];
	memset(newstring, 0, sizeof(char)*(len+1));

	p++;//"
	while(*p != '"' && size<=len)
	{
		while (*p != '\\' && *p != '"' && size<=len)
		{
			newstring[size] = *p;
			p++;
			size++;
		}
		if (size >= len)
			break;
		if (*p == '\\')
		{
			p++;
			switch (*p)
			{
				case '\\': newstring[size] = '\\'; break;
				case 'r':newstring[size] = 0x0d; break;
				case 'n':newstring[size] = 0x0a; break;
				case 't':newstring[size] = '\t'; break;
				default: 
					//	newstring[size] = '\\'; 
					//	size++;
					//	newstring[size] = 't';				
					GENERR(124);
					break;
			}
			p++;
			size++;
		}
		else
			break;
	}
	newstring[size] = 0;
	size++;
	return newstring;

}






#if 0
/*
函数名称     : cParser::NeedCast
函数功能	    : 判断是否需要类型转换, 并返回转换码和要转换的运算数
变量说明     : 
TYPEDES dt1 : 运算数1
TYPEDES dt2 : 运算数2
char &casted : [OUT]要被转换的运算数 
返回值       : 要进行的类型转换代号, -1表示不需要转换
编写人       : 居卫华
完成日期     : 2001 - 6 - 8
*/
long cParser::NeedCast(TYPEDES dt1, TYPEDES dt2, char &casted)
{
	casted = 0;
	TYPEDES DT1, DT2;
	//beckup
	memcpy(&DT1, &dt1, sizeof(TYPEDES));
	memcpy(&DT2, &dt2, sizeof(TYPEDES));

	/*
	//如果是指针, 则不能进行转换
	if (DT1.refLevel > 0 || DT2.refLevel > 0)
		return -1;

*/
	if ((DT1.objID > 0 && DT2.objID == 0 ) || (DT2.objID > 0 && DT1.objID == 0 ))
	{
		return -1;
	}
	//指针都转换成long
	if (DT1.refLevel > 0)
	{
		//指针不能同浮点进行运算 
		if (dt2.type ==dtFloat)
		{
			return -1;
		}
		dt1.type = dtLong;
		dt1.refLevel = 0;
	}

	if (DT2.refLevel > 0)
	{
		//指针不能同浮点进行运算 
		if (DT1.type == dtFloat)
		{
			return -1;
		}
		DT2.type = dtLong;
		DT2.refLevel = 0;
	}


	///////////////////////////////
	// code modify 2002-03-19
	///////////////////////////////
/*	
	original code:
	//如果类型相同, 不需要转换
	if (DT1.type == DT2.type)
		return -1;


	switch (DT1.type)
	{
	case dtFloat:
		{
			casted = 2;
			switch (DT2.type)
			{
			case dtChar: return __CAST_C2F;
			case dtShort: return __CAST_S2F;
			case dtInt: return __CAST_I2F;
			case dtLong: return __CAST_L2F;
			default:GENERR(110);return -1;
			}
		}
	case dtLong:
		{
			switch (DT2.type)
			{
			case dtChar: casted = 2; return __CAST_C2L;
			case dtShort: casted = 2; return __CAST_S2L;
			case dtInt: return -1;
			case dtFloat: casted = 1; return __CAST_L2F;
			default:GENERR(110);return -1;
			}
		}
	case dtInt:
		{
			switch (DT2.type)
			{
			case dtChar: casted = 2; return __CAST_C2I;
			case dtShort: casted = 2; return __CAST_S2I;
			case dtLong: return -1;
			case dtFloat: casted = 1; return __CAST_I2F;
			default:GENERR(110);return -1;
			}
		}
	case dtShort:
		{
			switch (DT2.type)
			{
			case dtChar: casted = 2; return __CAST_C2S;
			case dtInt: casted = 1; return __CAST_S2I;
			case dtLong: casted = 1;  return __CAST_S2L;
			case dtFloat: casted = 1; return __CAST_S2F;
			default:GENERR(110);return -1;
			}
		}
	case dtChar:
		{
			switch (DT2.type)
			{
			case dtShort: casted = 1;return __CAST_C2S;
			case dtInt: casted = 1; return __CAST_C2I;
			case dtLong: casted = 1;  return __CAST_C2L;
			case dtFloat: casted = 1; return __CAST_C2F;
			default:GENERR(110);return -1;
			}
		}
	default:GENERR(110);		
	}
*/
	/* new code:*/
	if (dt1.type == dt2.type)
		return -1;

	switch (dt1.type)
	{
	case dtFloat:
		{
			casted = 2;
			switch (dt2.type)
			{
			case dtChar: return __CAST_C2F;
			case dtShort: return __CAST_S2F;
			case dtInt: return __CAST_I2F;
			case dtLong: return __CAST_L2F;
			default:GENERR(110);return -1;
			}
		}
	case dtLong:
		{
			switch (dt2.type)
			{
			case dtChar: casted = 2; return __CAST_C2L;
			case dtShort: casted = 2; return __CAST_S2L;
			case dtInt: return -1;
			case dtFloat: casted = 1; return __CAST_L2F;
			default:GENERR(110);return -1;
			}
		}
	case dtInt:
		{
			switch (dt2.type)
			{
			case dtChar: casted = 2; return __CAST_C2I;
			case dtShort: casted = 2; return __CAST_S2I;
			case dtLong: return -1;
			case dtFloat: casted = 1; return __CAST_I2F;
			default:GENERR(110);return -1;
			}
		}
	case dtShort:
		{
			switch (dt2.type)
			{
			case dtChar: casted = 2; return __CAST_C2S;
			case dtInt: casted = 1; return __CAST_S2I;
			case dtLong: casted = 1;  return __CAST_S2L;
			case dtFloat: casted = 1; return __CAST_S2F;
			default:GENERR(110);return -1;
			}
		}
	case dtChar:
		{
			switch (dt2.type)
			{
			case dtShort: casted = 1;return __CAST_C2S;
			case dtInt: casted = 1; return __CAST_C2I;
			case dtLong: casted = 1;  return __CAST_C2L;
			case dtFloat: casted = 1; return __CAST_C2F;
			default:GENERR(110);return -1;
			}
		}
	case 0:// 空操作数(dummy type)
		return -1;
	default:GENERR(110);		
	}
	/* new code end.*/
///////////////////////////////
// code modify end. 2002-03-19 
///////////////////////////////

	GENERR(110);
	return -1;
}
#endif 
long cParser::NeedCast(TYPEDES dt1, TYPEDES dt2, char &casted)
{
	casted = 0;
	TYPEDES DT1, DT2;
	//beckup
	memcpy(&DT1, &dt1, sizeof(TYPEDES));
	memcpy(&DT2, &dt2, sizeof(TYPEDES));
	
	if (DT1.type == DT2.type || // same type
	 (dt1.refLevel>0 && dt2.refLevel>0) // both are pointer
	)
		return -1;
		
	if ( (DT1.refLevel > 0 && DT2.refLevel == 0) || (DT2.refLevel > 0 && DT1.refLevel == 0) ){
		fprintf(stderr, "pointer cannot operat with non-pointer");
		GENERR(110);		
		return -1;
	}
	

	if (dt1.type == dt2.type)
		return -1;

	switch (dt1.type)
	{
	case dtFloat:
		{
			casted = 2;
			switch (dt2.type)
			{
			case dtChar: return __CAST_C2F;
			case dtShort: return __CAST_S2F;
			case dtInt: return __CAST_I2F;
			case dtLong: return __CAST_L2F;
			default:GENERR(110);return -1;
			}
		}
	case dtLong:
		{
			switch (dt2.type)
			{
			case dtChar: casted = 2; return __CAST_C2L;
			case dtShort: casted = 2; return __CAST_S2L;
			case dtInt: return -1;
			case dtFloat: casted = 1; return __CAST_L2F;
			default:GENERR(110);return -1;
			}
		}
	case dtInt:
		{
			switch (dt2.type)
			{
			case dtChar: casted = 2; return __CAST_C2I;
			case dtShort: casted = 2; return __CAST_S2I;
			case dtLong: return -1;
			case dtFloat: casted = 1; return __CAST_I2F;
			default:GENERR(110);return -1;
			}
		}
	case dtShort:
		{
			switch (dt2.type)
			{
			case dtChar: casted = 2; return __CAST_C2S;
			case dtInt: casted = 1; return __CAST_S2I;
			case dtLong: casted = 1;  return __CAST_S2L;
			case dtFloat: casted = 1; return __CAST_S2F;
			default:GENERR(110);return -1;
			}
		}
	case dtChar:
		{
			switch (dt2.type)
			{
			case dtShort: casted = 1;return __CAST_C2S;
			case dtInt: casted = 1; return __CAST_C2I;
			case dtLong: casted = 1;  return __CAST_C2L;
			case dtFloat: casted = 1; return __CAST_C2F;
			default:GENERR(110);return -1;
			}
		}
	case 0:// 空操作数(dummy type)
		return -1;
	default:GENERR(110);		
	}
	
	return 0;
}
/*
   函数名称     : cParser::AllocTempVar
   函数功能	    : 分配一个临时变量
   变量说明     : 
   long type	: 变量的类型
   返回值       : 变量的地址, -1 表示失败
   编写人       : 居卫华
   完成日期     : 2001 - 6 - 8
*/
long cParser::AllocTempVar(long type, long reflevel)
{
	_typedes(dt1, type)
	dt1.refLevel = reflevel;

	long temp;
	if (m_pMainFunction->AddVal(NULL,  dt1))
	{			
		temp = m_pMainFunction->m_SymbolTable.tableEntry[m_pMainFunction->m_SymbolTable.m_nSymbolCount-1].address;		
		return temp;
	}
	else
		return -1;				
}

/*
   函数名称     : cParser::Cast
   函数功能	    : 自动类型转换
   变量说明     : 
   返回值       : 
   编写人       : 居卫华
   完成日期     : 2001 - 6 - 11
*/
void cParser::Cast(long &op1, long &type1, TYPEDES &dt1, long &op2, long &type2, TYPEDES &dt2)
{
// change by jackie ju at 20110512
// 
#if 0
/***** old code ********
			long castcode = -1; //cast操作码
			char casted = 0;	//被转换类型的运算数
			castcode = NeedCast(dt1, dt2, casted);
			if (castcode != -1)
			{
				//类型转换
				long temp;//临时变量地址, 存放转换后的变量
				long type;//目标类型
				long am;  //cast指令的寻址方式
				long* castedop = NULL;
				if (casted == 1)
				{
					type = dt2.type;
					castedop = &op1;
				}
				if (casted == 2)
				{
					type = dt1.type;
					castedop = &op2;
				}
				temp = AllocTempVar(type);
				if (temp == -1)
				{
					GENERR(98);
				}
				else
				{
					am = 1 | (log2((int)(typesize(type, 0))<<6));
					am = am << 8;//temp的寻址方式
					if (casted == 1)
					{			
						long exchange = am>>8;						
						am |= (type1&0x00ff) /*| (((type2&0x30)<<8)&0xff00)*/;//整条指令的寻址方式
					ADDCOMMAND3(__cast, am, temp, *castedop, castcode)
						//修改运算数
						op1 = temp;
						type1 = exchange;
						dt1.type = type;
					}
					if (casted == 2)
					{
						long exchange = am >> 8;
						am |= (type2&0xff) /*| (((type1&0x30)<<8)&0xff00)*/;//整条指令的寻址方式					
					ADDCOMMAND3(__cast, am, temp, *castedop, castcode)
						//修改运算数
						op2 = temp;
						type2 = exchange;
						dt2.type = type;
					}
				}				
			}*/
#endif		
			/***** new code *****/
			// check if need cast
			char casted = 0; // which operand need to be cast
			if (NeedCast(dt1, dt2, casted) <=0)
				return;
				
				long temp = -1;//临时变量地址, 存放转换后的变量
				long t_type;//目标类型
				long t_ref;
				long* castedop = NULL;
				int address_mode = 0;
				if (casted == 1)
				{
					t_type = dt2.type;
					castedop = &op1;
					t_ref = dt2.refLevel;
			
				}
				if (casted == 2)
				{
					t_type = dt1.type;
					castedop = &op2;
					t_ref = dt1.refLevel;
				}

				temp = AllocTempVar(t_type, t_ref);

				if (temp == -1)
				{
					GENERR(98);
				}
				else
				{
				
				 
					if (casted == 1)
					{		
						address_mode = 	getAddressMode2(AMODE_MEM, type1, dt2, dt1);
						ADDCOMMAND4(__movobj, address_mode, temp, op1, t_type<<4|t_ref, dt1.type<<4|dt1.refLevel) 
						//修改运算数
						op1 = temp;
						type1 = AMODE_MEM;
						dt1.type = t_type;
					}
					if (casted == 2)
					{
						address_mode = 	getAddressMode2(AMODE_MEM, type2, dt1, dt2);
						ADDCOMMAND4(__movobj, address_mode, temp, op2, t_type<<4|t_ref, dt2.type<<4|dt2.refLevel) 
						//修改运算数
						op2 = temp;
						type2 = AMODE_MEM;
						dt2.type = t_type;
					}
				}
			
			
			
			/***** end change ***/

}

BOOL cParser::AddClass(CClassDes& obj)
{
/*
	if (this->m_lClassDesNum == this->m_lClassDesTableSize)
	{
		CClassDes** pNewTable = NULL;

		pNewTable = new CClassDes*[m_lClassDesTableSize+50];
		if (pNewTable == NULL)
		{
			REPORT_MEM_ERROR("Memory allocation failed\r\n");
			return FALSE;
		}
		memcpy(pNewTable, this->m_classTable, sizeof(CClassDes*)*m_lClassDesNum);
		delete this->m_classTable;
		this->m_classTable = pNewTable;		
		m_lClassDesTableSize += 50;
	}
	m_classTable[m_lClassDesNum] = &obj;
	this->m_lClassDesNum++;
    m_pCurClassDes = &obj;
	return TRUE;
*/
    m_classTable->addClass(&obj);
	std::string msg = "add classes";
	debug((char*)msg.c_str());
    return TRUE;

}
/*
long cParser::GetClassIdByName(char *szName)
{	

	int i;
	char * name;
	for (i = 0; i< m_lClassDesNum; i++)
	{
		name = (*m_classTable)[i]->GetFullName();
		if (!strcmp(name, szName))
			return i+1;
	}
	return 0;


}
	*/



void cParser::SetByteCodeFilePath(char* szPath)
{
	if (szPath == NULL)
		return;
	strcpy(m_szByteCodeFilePath, szPath);
	while (m_szByteCodeFilePath[strlen(m_szByteCodeFilePath) - 1] == PATH_SEPARATOR_C)
		m_szByteCodeFilePath[strlen(m_szByteCodeFilePath) - 1] = 0; 
}


cParser::cParser(CCompiler* c, AbsScanner *S, CRError *E) : CRParser(S,E)
{
	m_conf = NULL;
	
	m_LoopTree = new CLoopTree();

	m_pMainFunction = new CFunction;



	m_pExpOpPt = &m_ExpOp;
	m_ExpOp.pPrev = NULL; 


	m_curloop  = m_LoopTree;

	m_classTable = NULL;
	m_lClassDesNum = 0;
	m_lClassDesTableSize = 0;

	m_szByteCodeFilePath[0] = 0;
    m_pCurClassDes = NULL;
    memset(curFileName, 0, _MAX_PATH);

    this->c = c;
}

cParser::~cParser()
{

	/*if (this->m_classTable)
	{
		for (int i= 0; i < this->m_lClassDesNum; i++)
		{
			if (m_classTable[i])
				delete m_classTable[i];
		}
		delete m_classTable;
	}*/

	SAFEDELETE(m_LoopTree);
    SAFEDELETE(m_pMainFunction);
}


bool cParser::doMove(long type1, long type2, long op1, long op2, TYPEDES& dt1, TYPEDES& dt2 )
{
	//get address mode
	int address_mode = getAddressMode2(type1, type2, dt1, dt2);
/*
	if (dt1.type != dtGeneral && dt2.type != dtGeneral){

		//add commmand to command table
		ADDCOMMAND2(__mov, address_mode, op1, op2)      
		pushResultAX();
	}
	else{
		if (dt2.type == dtGeneral && dt1.type != dtGeneral) {// can not assign object to primitive type
			this->GENERR(11); // TODO
			fprintf(stderr, "Cannot assign objrct o primitive type");
		}
	//	int source_type = dt2.type;
	//	if (dt1.type == dtGeneral && dt2.type == dtChar && dt2.refLevel == 1) // char* => object{
	//		source_type = dtString;
	//	}
		//add commmand to command table
		printf("==>movobj");
		ADDCOMMAND4(__movobj, address_mode, op1, op2, dt1.type<<4|dt1.refLevel, dt2.type<<4|dt2.refLevel)      
		m_pMainFunction->PushDigit(op1, AMODE_OBJ|0x80, dt1);
	}*/

	ADDCOMMAND4(__movobj, address_mode, op1, op2, dt1.type<<4|dt1.refLevel, dt2.type<<4|dt2.refLevel) 
	m_pMainFunction->PushDigit(op1, AMODE_MEM|0x80, dt1);
//	pushResultAX();    
	return true;
}

// do variable allocation and push it into stack, the top element in stack is array info
void cParser::doVarDecl(PTYPEDES type, char* szFirstName)
{
//printf("-=====>1111, %x\n", m_pMainFunction->m_pExpDigitPt);
     long op;
	      long type1;
	      TYPEDES DT1;
	      if (!m_pMainFunction->PopDigit(&op, &type1, &DT1))
	      {
	              if (!AllocVar(type, szFirstName))
	                      GENERR(113);
				  else{
					  long temp =  m_pMainFunction->m_SymbolTable.tableEntry[m_pMainFunction->m_SymbolTable.m_nSymbolCount-1].address;
					  m_pMainFunction->PushDigit(temp, AMODE_MEM|0x80, *type);
				  }
	      }
	      else
	      { 
	              if (type1 >=FIRST_ADDRESS_MODE || type1 >LAST_ADDRESS_MODE)
	              {
	                      //error
	              };
	              /*              int i;
	              BOOL bPop = TRUE;
	              while (!bPop)
	              {       
	              if (type1 != AMODE_DIRECT)
	              {
	              //error
	              }
	              for ( i= 0; i<op; i++0)
	              {
	              AllocVar(type, NULL);
	              }
	              bPop = m_pMainFunction->PopDigit(&op, type1);
	              }
	              */      

	              int dimsize[64];//数组最大维数64
	              int i = 0;
	              int arraysize = op;//total size
	              dimsize[i] = op;
	              i++;

	              while (m_pMainFunction->PopDigit(&op, &type1, &DT1))
	              {
	                      dimsize[i] = op;                        
	                      i++;
	                      arraysize *= op;
	              }
	              type->dim = i;
	              int k,j;
	              k = 0;
	              for (j=i-1; j>=0; j--)
	              {
	                      type->dimsize[j] = dimsize[k];
	                      k++;
	              }

	              if (!AllocArrayVar(type, szFirstName, arraysize))
	                      GENERR(113);
				  else{
					  long temp =  m_pMainFunction->m_SymbolTable.tableEntry[m_pMainFunction->m_SymbolTable.m_nSymbolCount-1].address;
					  m_pMainFunction->PushDigit(temp, AMODE_MEM|0x80, DT1);
				  }
	      }
}
void cParser::pushResultAX(){
	//push result
	TYPEDES dt;//无效
	memset(&dt, 0, sizeof(TYPEDES));
	this->m_pMainFunction->PushDigit(_AX, 0x82,dt);
}
bool cParser::doAssign()
{
printf("==>do Assign\n");
    //add command
    long op1, op2;
    long type1, type2;
    TYPEDES dt1, dt2;

    //pop
    if (!m_pMainFunction->PopDigit(&op2, &type2, &dt2) || !m_pMainFunction->PopDigit(&op1, &type1, &dt1) 
    || type1 <FIRST_ADDRESS_MODE || type1 >LAST_ADDRESS_MODE 
    || type2 <FIRST_ADDRESS_MODE || type2 >LAST_ADDRESS_MODE)
    {
			debug("type1=%x, type2=%x\n", type1, type2);
    //      REPORT_COMPILE_ERROR("POP UP FAILED");
            GENERR(96);
            return false;
    }
    else
    {
		if (dt1.type == dtUnknown){ // not decleared variable
			dt1.type = dtGeneral;
			char name1[1024] = "";
			long variable_address = AllocVar(&dt1, (char*)name1);
	   		ADDCOMMAND1(__newobj,DS, -1); // create object and set to AX
			
		}
            //类型转换
            long castcode = -1; //cast操作码
            char casted = 0;        //被转换类型的运算数
            //类型转换
            long temp;//临时变量地址, 存放转换后的变量
            long type;//目标类型
            long level;
            long objid;
            long am;  //cast指令的寻址方式
            long* castedop = NULL;
            type = dt1.type;
            level = dt1.refLevel;
            castedop = &op2;
            objid = dt1.objID;
		    if (dt1.type != dtGeneral && dt2.type != dtGeneral) //get cast code
            {
				    TYPEDES DT1, DT2;
                    memcpy(&DT1, &dt1, sizeof(TYPEDES));
                    memcpy(&DT2, &dt2, sizeof(TYPEDES));
	debug("==>111   type1=%x, type2=%x, DT1.refLevel=%d, DT2.refLevel=%d\n", type1, type2, DT1.refLevel, DT2.refLevel);
              
                    if ( (DT1.objID > 0 && DT2.objID ==0) || (DT2.objID > 0 && DT1.objID ==0))
                    {
                            GENERR(110);
                            return false;
                    }

                    if (DT1.refLevel > 0)//是指针
                    {
                            if (DT2.refLevel == 0 // 不是指针
                                    && DT2.type != dtLong //不是长整型
                                    && DT2.type != dtInt)
                            {
                                    GENERR(110);
                                    return false;
                            }
                            DT1.type = dtLong;                                      
                    }
                    if (DT2.refLevel > 0)
                    {
                            if (DT1.refLevel == 0 && DT1.type != dtLong &&DT1.type != dtInt)
                            {
                                    GENERR(110);
                                    return false;
                            }
                            DT2.type = dtLong;                                      
                    } 
					debug("DT2.type=%x, DT1.type=%x\n", DT2.type, DT1.type);
                    switch (DT2.type)
                    {
                    case dtChar:
                            {
                                    switch (DT1.type)
                                    {
                                    case dtChar:break;
                                    case dtShort:castcode = __CAST_C2S;break;
                                    case dtInt:castcode = __CAST_C2I;break;
                                    case dtLong:castcode = __CAST_C2L;break;
                                    case dtFloat:castcode = __CAST_C2F;break;
                                    default:GENERR(110);return false;
                                    }                                               
                            }
                            break;
                    case dtShort:
                            {
                                    switch (DT1.type)
                                    {
                                    case dtChar:castcode = __CAST_S2C;break;
                                    case dtShort:break;
                                    case dtInt:castcode = __CAST_S2I;break;
                                    case dtLong:castcode = __CAST_S2L;break;
                                    case dtFloat:castcode = __CAST_S2F;break;
                                    default:GENERR(110);return false;
                                    }                                               
                            }
                            break;
                    case dtInt:
                     {
                                                switch (DT1.type)
                                                {
                                                case dtChar:castcode = __CAST_I2C;break;
                                                case dtShort:castcode = __CAST_I2S;break;                                                     
                                                case dtFloat:castcode = __CAST_I2F;break;
                                                case dtInt:
                                                case dtLong:
                                                                                            case dtStr:break; // not need to cast

                                                default:GENERR(110);return false;
                                                }                                               
                                        }
                            break;
                    case dtLong:
                            {
                                    switch (DT1.type)
                                    {
                                    case dtChar:castcode = __CAST_L2C;break;
                                    case dtShort:castcode = __CAST_L2S;break;
                                    case dtInt:break;
                                    case dtLong:break;
                                    case dtFloat:castcode = __CAST_L2F;break;
                                    default:GENERR(110);return false;
                                    }                                               
                            }
                            break;
                    case dtFloat:
                            if (DT1.type != dtFloat) 
                                    GENERR(110);
                            break;
                    } // switch
            } // if 
            temp = AllocTempVar(type, level);
            if (temp == -1)
            {
                    GENERR(98);
            }
            else if (castcode != -1)
            {//需要转换

                    am = 1 | (log2(UnitSize(dt1))<<6);
                    am = am << 8;//temp的寻址方式
                    long exchange = am >> 8;
                    am |= (type2&0xff) /*| (((type2&0x30)<<8)&0xff00)*/;//整条指令的寻址方式                                        
                    ADDCOMMAND3(__cast, am, temp, *castedop, castcode)
                    //修改运算数
                    type2 = exchange;
                    dt2.type = type;
                    op2 = temp;
            }                               

            doMove(type1, type2, op1, op2, dt1, dt2);

     } // else
    return true;

}
// add by jackie juju
//////////////////////////////////
